# THIS FILE IS AUTOGENERATED. DO NOT EDIT.

_callbacks = {
    "UnivariateDistribution": """
class UnivariateDistribution {
  constructor(parametrization) {
    
    this.name = '';

    
    this.varName = '';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.p1Value = Infinity;

    
    this.parametrization = parametrization

    
    this.paramNames = [];

    
    this.locationParam = undefined;
    this.locatonParamIndex = undefined;

    
    this.paramMin = [];

    
    this.paramMax = [];

    
    this.fixedParams = [];

    
    this.epsilon = 1.0e-8;
  }

  generateLocationParamIndex() {
    if (this.locationParam === undefined) {
      this.locationParamInd = undefined;
    } else {
      this.locationParamInd = this.paramNames.indexOf(this.locationParam);
    }
  }

  generateActiveFixedInds() {
    
    this.activeParamsInds = [];
    this.fixedParamsInds = []
    for (let i = 0; i < this.paramNames.length; i++) {
      if (this.fixedParams.includes(this.paramNames[i])) {
        this.fixedParamsInds.push(i);
      } else {
        this.activeParamsInds.push(i);
      }
    }
  }

  xMin(params, parametrization = this.parametrization) {
    
  }

  xMax(params, parametrization = this.parametrization) {
    
  }

  cdfSingleValue({x, params, parametrization = this.parametrization}) {
    
  }

  ppfSingleValue(p, params, parametrization = this.parametrization) {
    
  }

  quantileSet(x, p, parametrization = this.parametrization) {
    
  }

  defaultXRange(params, parametrization = this.parametrization) {
    
  }


  cdf(x, params, parametrization = this.parametrization) {
    params = this.scalarToArrayParams(params);

    return this.scalarOrArrayCompute(
      (x, params) => this.cdfSingleValue(x, params, parametrization),
      x,
      params
    );
  }

  ppfSingleValueWithCheck(p, params, parametrization = this.parametrization) {
    if (p < 0 || p > 1) return NaN;
    return this.ppfSingleValue(p, params, parametrization);
  }

  ppf(p, params, parametrization = this.parametrization) {
    params = this.scalarToArrayParams(params);

    return this.scalarOrArrayCompute(
      (p, params) => this.ppfSingleValueWithCheck(p, params, parametrization),
      p,
      params
    );
  }

  resetXRange(params, p, parametrization = this.parametrization) {
    if (p === undefined) {
      return this.defaultXRange(params, parametrization);
    } else if (this.checkResetp(p)) {
      return this.ppf(p, params, parametrization);
    }
  }

  scalarOrArrayCompute(func, x, params, parametrization = this.parametrization) {
    if (x instanceof Array) {
      let xLen = x.length;

      let res = [];
      for (let i = 0; i < xLen; i++) {
        res.push(func(x[i], params, parametrization));
      }

      return res;
    } else {
      return func(x, params, parametrization);
    }
  }

  scalarToArrayParams(params) {
    return params instanceof Array ? params : [params]
  }
}
""",
    "DiscreteUnivariateDistribution": """
class DiscreteUnivariateDistribution extends UnivariateDistribution {
  constructor(parametrization) {
    super(parametrization);
  }

  pmfSingleValue(x, params, parametrization = this.parametrization) {
    
  }

  pmf(x, params, parametrization = this.parametrization) {
    params = this.scalarToArrayParams(params);

    return this.scalarOrArrayCompute(
      (x, params) => this.pmfSingleValue(x, params, parametrization),
      x,
      params);
  }

  cdfSingleValue(x, params, parametrization = this.parametrization) {
    params = this.scalarToArrayParams(params);

    
    let cumsum = 0.0;
    let summand = 0.0;
    for (let n = this.xMin(params, parametrization); n <= x; n++) {
        summand = this.pmfSingleValue(n, params, parametrization);
        if (!isNaN(summand)) cumsum += summand;
    }

    return cumsum;
  }

  cdfForPlotting(xStart, xEnd, params, parametrization = this.parametrization) {

    params = this.scalarToArrayParams(params);

    
    let cumsum;
    let y_c;
    let prob;
    if (Number.isInteger(xStart)) {
      
      cumsum = this.cdfSingleValue(Math.floor(xStart) - 1, params, parametrization);

      if (Number.isInteger(xEnd)) {
        y_c = [cumsum];
        for (let x = xStart; x < xEnd; x++) {
          prob = this.pmfSingleValue(x, params, parametrization);
          if (!isNaN(prob)) cumsum += prob;
          y_c.push(cumsum, cumsum);
        }
        prob = this.pmfSingleValue(xEnd, params, parametrization);
        if (!isNaN(prob)) cumsum += prob;
        y_c.push(cumsum);
      }
      else {
        y_c = [cumsum];
        for (let x = xStart; x <= Math.floor(xEnd); x++) {
          prob = this.pmfSingleValue(x, params, parametrization);
          if (!isNaN(prob)) cumsum += prob;
          y_c.push(cumsum, cumsum);
        }
      }
    }
    else {
      
      cumsum = this.cdfSingleValue(Math.floor(xStart), params, parametrization);

      if (Number.isInteger(xEnd)) {
        y_c = [cumsum, cumsum];
        for (let x = Math.ceil(xStart); x < xEnd; x++) {
          prob = this.pmfSingleValue(x, params, parametrization);
          if (!isNaN(prob)) cumsum += prob;
          y_c.push(cumsum, cumsum);
        }
        prob = this.pmfSingleValue(xEnd, params, parametrization);
        if (!isNaN(prob)) cumsum += prob;
        y_c.push(cumsum);        
      }
      else {
        y_c = [cumsum, cumsum];
        for (let x = Math.ceil(xStart); x <= xEnd; x++) {
          prob = this.pmfSingleValue(x, params, parametrization);
          if (!isNaN(prob)) cumsum += prob;
          y_c.push(cumsum, cumsum);
        }
      }    
    }

    return y_c;
  }

  ppfSingleValue(p, params, parametrization = this.parametrization) {
    if (p < 0 || p > 1) throw new Error('p must be between 0 and 1.')

    
    if (p == 0) return xMin(params, parametrization);

    
    if (p == 1) return xMax(params, parametrization);

    params = this.scalarToArrayParams(params);

    
    let n = this.xMin(params, parametrization);
    let cumsum = this.pmfSingleValue(n, params, parametrization);

    let iters = 0;
    let summand = 0.0;
    let xMaxForTheseParams = this.xMax(params, parametrization);
    while (cumsum < p && !isclose(cumsum, p) && !isNaN(summand) && n < xMaxForTheseParams) {
      n += 1;
      summand = this.pmfSingleValue(n, params, parametrization);

      if (!isNaN(summand)) cumsum += summand;

      iters += 1;
    }

    return n;
  }

}
""",
    "ContinuousUnivariateDistribution": """
class ContinuousUnivariateDistribution extends UnivariateDistribution {
  constructor(parametrization) {
    super(parametrization);
  }

  pdfSingleValue(x, params, parametrization = this.parametrization) {
    
  }

  pdf(x, params, parametrization = this.parametrization) {
    params = this.scalarToArrayParams(params);

    return this.scalarOrArrayCompute(
      (x, params) => this.pdfSingleValue(x, params, parametrization),
      x,
      params
    );
  }

}
""",
    "TemplateDiscreteUnivariateDistribution": """
class TemplateDiscreteUnivariateDistribution extends DiscreteUnivariateDistribution {
  
  
  constructor() {
    super();

    
    this.name = '';

    
    this.varName = '';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = [];

    
    this.paramMin = [];

    
    this.paramMax = [];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()

    
  }

  xMin(params, parametrization = this.parametrization) {
    
  }

  xMax(params, parametrization = this.parametrization) {
    
  }

  pmfSingleValue(x, params, parametrization = this.parametrization) {
    
  }

  defaultXRange(params, parametrization = this.parametrization) {
    
  }

  quantileSet(x, p, extraParams = [], parametrization = this.parametrization) {
    
  }

}
""",
    "TemplateContinuousUnivariateDistribution": """
class TemplateContinuousUnivariateDistribution extends ContinuousUnivariateDistribution {
  
  
  constructor() {
    super();

    
    this.name = '';

    
    this.varName = '';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = [];

    
    this.locationParam = undefined;

    
    this.paramMin = [];

    
    this.paramMax = [];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();

    
  }

  xMin(params, parametrization = this.parametrization) {
    
  }

  xMax(params, parametrization = this.parametrization) {
    
  }

  pdfSingleValue(x, params, parametrization = this.parametrization) {
    
  }

  cdfSingleValue(x, params, parametrization = this.parametrization) {
    
  }

  ppfSingleValue(p, params, parametrization = this.parametrization) {
    
  }

  defaultXRange(params, parametrization = this.parametrization) {
    
  }

  quantileSet(x, p, extraParams = [], parametrization = this.parametrization) {
    
  }

  
}
""",
    "BernoulliDistribution": """
class BernoulliDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Bernoulli';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = 1;

    
    this.paramNames = ['θ'];

    
    this.paramMin = [0.0];

    
    this.paramMax = [1.0];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return 1;
  }

  pmfSingleValue(x, params) {
    let theta = params[0];

    if (x == 0) return 1 - theta;
    else if (x == 1) return theta;
    else return NaN;
  }

  ppfSingleValue(p, params) {
    if (p <= params[0]) return 0;
    else return 1;
  }

  defaultXRange(params) {
    return [-0.2, 1.2];
  }

  quantileSet(x, p, extraParams) {
    let x1 = x[0];
    let p1 = p[0];

    if (x1 != 0) {
      throw new Error(this.varName + ' must be zero.')
    }

    return [[1 - p1], true];
  }
}
""",
    "BetaBinomialDistribution": """
class BetaBinomialDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'BetaBinomial';

    
    this.varName = 'n';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['N', 'α', 'β'];

    
    this.paramMin = [0, 0.0, 0.0];

    
    this.paramMax = [Infinity, 1.0, 1.0];

    
    this.fixedParams = ['N'];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return params[0];
  }

  pmfSingleValue(n, params) {
    let [N, alpha, beta] = params.slice(0, 3);

    if (n > N || n < 0) return NaN;

    return Math.exp(lnchoice(N, n) + lnbeta(n + alpha, N - n + beta) - lnbeta(alpha, beta));
  }

  ppfSingleValue(p, params) {
    let [N, alpha, beta] = params.slice(0, 3);

    return super.ppfSingleValue(p, params, 0, N, N);
  }

  defaultXRange(params) {
    let [N, alpha, beta] = params.slice(0, 3);

    return [-1, N + 1];
  }

}
""",
    "BinomialDistribution": """
class BinomialDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Binomial';

    
    this.varName = 'n';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['N', 'θ'];

    
    this.paramMin = [0, 0.0];

    
    this.paramMax = [Infinity, 1.0];

    
    this.fixedParams = ['N'];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return params[0];
  }

  pmfSingleValue(n, params) {
    let [N, theta] = params.slice(0, 2);

    if (n > N || n < 0) return NaN;

    if (theta == 0) {
      if (n == 0) return 1.0;
      return 0.0;
    }

    if (theta == 1) {
      if (n == N) return 1.0;
      return 0.0;
    }

    return Math.exp(lnchoice(N, n) +
      n * Math.log(theta) +
      (N - n) * Math.log(1 - theta));
  }

  cdfSingleValue(n, params) {
    let [N, theta] = params.slice(0, 2);

    if (n < 0) return 0.0;
    if (n >= N) return 1.0;
    return regularizedIncompleteBeta(1.0 - theta, N - n, n + 1);
  }

  ppfSingleValue(p, params) {
    let [N, theta] = params.slice(0, 2);
    
    return super.ppfSingleValue(p, params, 0, N, N);
  }

  defaultXRange(params) {
    let [N, theta] = params.slice(0, 2);

    if (N < 50) {
      return [-1, N + 1];
    } else {
      return this.ppf([0.001, 0.999], params);
    }
  }

  quantileSet(x, p, extraParams) {
    let x1 = x[0];
    let p1 = p[0];
    let N = extraParams[0];

    if (!Number.isInteger(x1)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0) {
      throw new Error('Must have ' + this.varName + ' > 0.')
    }
    if (x1 >= N) {
      throw new Error('Must have ' + this.varName + ' < N.')
    }

    
    let rootFun = (theta, N) => p1 - this.cdfSingleValue(x1, [N, theta]);

    let thetaOpt = brentSolve(rootFun, 0.0, 1.0, [N]);
    let optimSuccess = thetaOpt != null;
    
    return [[thetaOpt], optimSuccess];
  }
}
""",
    "CategoricalDistribution": """
class CategoricalDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Categorical';

    
    this.varName = 'y';

    
    this.hardMin = 1;
    this.hardMax = 4;

    
    this.paramNames = ['θ1', 'θ2', 'θ3'];

    
    this.paramMin = [0.0, 0.0, 0.0];

    
    this.paramMax = [1.0, 1.0, 1.0];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 1;
  }

  xMax(params) {
    return 4;
  }

  pmfSingleValue(cat, params) {
    let [theta1, theta2, theta3] = params.slice(0, 3);
    let theta4 = 1 - theta1 - theta2 - theta3

    
    if (theta4 < 0) return NaN;

    
    if (![1, 2, 3, 4].includes(cat)) return NaN;

    let probs = [theta1, theta2, theta3, theta4]

    return probs[cat-1];
  }

  defaultXRange(params) {
    return [-0.25, 4.25];
  }

  cdfSingleValue(x, params, xMin = 0) {
    
    let [theta1, theta2, theta3] = params.slice(0, 3);
    let theta4 = 1 - theta1 - theta2 - theta3

    
    if (theta4 < 0) return NaN;

    
    let cumsum = 0.0;
    let summand = 0.0;
    for (let n = xMin; n <= x; n++) {
        summand = this.pmfSingleValue(n, params);
        if (!isNaN(summand)) cumsum += summand;
    }

    return cumsum;
  }
}
""",
    "DiscreteUniformDistribution": """
class DiscreteUniformDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'DiscreteUniform';

    
    this.varName = '';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['low', 'high'];

    
    this.paramMin = [-Infinity, -Infinity];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return params[0];
  }

  xMax(params) {
    return params[1];
  }

  pmfSingleValue(n, params) {
    let [low, high] = params.slice(0, 2);

    if (low > high || n < low || n > high) return NaN;

    return 1 / (high - low + 1);
  }

  ppfSingleValue(p, params) {
    let [low, high] = params.slice(0, 2);
    
    return super.ppfSingleValue(p, params, low, high, high);
  }

  defaultXRange(params) {
    let [low, high] = params.slice(0, 2);

    return [low - 1, high + 1];
  }

}
""",
    "GeometricDistribution": """
class GeometricDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Geometric';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['θ'];

    
    this.paramMin = [0.0];

    
    this.paramMax = [1.0];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return Infinity;
  }

  pmfSingleValue(x, params) {
    let theta = params[0];

    if (theta == 1) {
      if (x == 0) return 1.0;
      return 0.0;
    }

    if (theta == 0) return 0.0;

    if (x < 0) return NaN;

    return Math.exp(x * Math.log(1.0 - theta) + Math.log(theta));
  }

  cdfSingleValue(x, params) {
    if (x < 0) return 0.0;
    if (x === Infinity) return 1.0;

    let theta = params[0];

    return 1.0 - Math.pow(1.0 - theta, x + 1.0);
  }

  ppfSingleValue(p, params) {
    let theta = params[0];

    if (p === 0) return 0;
    if (p === 1) return Infinity;
    if (theta === 1) return 0;

    let res = Math.ceil(Math.log(1 - p) / Math.log(1 - theta) - 1);

    if (res === -0) return 0;
    return res;
  }

  defaultXRange(params) {
    let theta = params[0];

    return [-1, this.ppfSingleValue(0.999, params)];
  }

  quantileSet(x, p) {
    let x1 = x[0];
    let p1 = p[0];

    if (!Number.isInteger(x1)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0) {
      throw new Error('Must have ' + this.varName + ' > 0.')
    }

    return [[1.0 - Math.pow(1.0 - p1, 1.0 / (x1 + 1.0))], true];
  }

}
""",
    "HypergeometricDistribution": """
class HypergeometricDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Hypergeometric';

    
    this.varName = 'n';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['N', 'a', 'b'];

    
    this.paramMin = [0, 0, 0];

    
    this.paramMax = [Infinity, Infinity, Infinity];

    
    this.fixedParams = ['N'];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    let [N, a, b] = params.slice(0, 3);
    return Math.max(0, N - b);
  }

  xMax(params) {
    let [N, a, b] = params.slice(0, 3);
    return Math.min(N, a);
  }

  pmfSingleValue(n, params) {
    let [N, a, b] = params.slice(0, 3);

    if (n < Math.max(0, N - b) || n > Math.min(N, a)) return NaN;

    return Math.exp(lnchoice(a, n) + lnchoice(b, N - n) - lnchoice(a + b, N));
  }

  ppfSingleValue(p, params) {
    return super.ppfSingleValue(p, params, this.xMin(params), this.xMax(params), this.xMax(params));
  }

  defaultXRange(params) {
    let [N, a, b] = params.slice(0, 3);

    return [Math.max(0, N - b) - 1, Math.min(N, a) + 1];
  }
}
""",
    "NegativeBinomialDistribution": """
class NegativeBinomialDistribution extends DiscreteUnivariateDistribution {
  constructor(parametrization = 'alpha-beta', fixedParam = undefined) {
    super(parametrization);

    
    this.name = 'NegativeBinomial';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    if (this.parametrization === 'alpha-beta') {
      this.paramNames = ['α', 'β'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
      if (fixedParam === undefined) this.fixedParams = ['α'];
      else this.fixedParams = [fixedParam];
    } else if (this.parametrization === 'mu-phi') {
      this.paramNames = ['μ', 'φ'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
      if (fixedParam === undefined) this.fixedParams = ['φ'];
      else this.fixedParams = [fixedParam];
    } else if (this.parametrization === 'alpha-p') {
      this.paramNames = ['α', 'p'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, 1.0];
      if (fixedParam === undefined) this.fixedParams = ['α'];
      else this.fixedParams = [fixedParam];
    } else if (this.parametrization === 'r-b') {
      this.paramNames = ['r', 'b'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
      if (fixedParam === undefined) this.fixedParams = ['r'];
      else this.fixedParams = [fixedParam];
    } else { 
      this.paramNames = ['unnamedParam1', 'unnamedParam2'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
      if (fixedParam === undefined) this.fixedParams = ['unnamedParam1'];
      else this.fixedParams = [fixedParam];
    }

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return Infinity;
  }

  convertParams(params, from = this.parametrization, to = 'alpha-beta') {
    if (from === to) return params;
    else if (to === 'alpha-beta') return this.convertParamsToAlphaBeta(params, from);
    else if (from === 'alpha-beta') return this.convertParamsFromAlphaBeta(params, to);
    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);
  }

  convertParamsToAlphaBeta(params, from = this.parametrization) {
    
    let alpha, beta;

    if (from === 'mu-phi') {
      let [mu, phi] = params.slice(0, 2);
      alpha = phi;
      beta = alpha / mu;
    } else if (from === 'alpha-p') {
      let [a, p] = params.slice(0, 2);
      alpha = a;
      beta = p / (1 - p);
    } else if (from === 'r-b') {
      let [r, b] = params.slice(0, 2);
      alpha = r;
      beta = 1 / b;
    } else if (from === 'alpha-beta') {
      [alpha, beta] = params.slice(0, 2);
    } else {
      throw new Error('Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.');
    }

    return [alpha, beta];
  }

  convertParamsFromAlphaBeta(params, to = this.parametrization) {
    
    let [alpha, beta] = params.slice(0, 2);

    let output;
    if (to === 'mu-phi') {
      let mu = alpha / beta;
      let phi = alpha;
      output = [mu, phi];
    } else if (to === 'alpha-p') {
      let a = alpha;
      let p = beta / (1 + beta);
      output = [a, p];
    } else if (to === 'r-b') {
      let r = alpha;
      let b = 1 / beta;
      output = [r, b];
    } else if (to === 'alpha-beta') {
      output = [alpha, beta];
    } else {
      throw new Error('Invalid parametrization for converting. Allowed values are alpha-beta, mu-phi, alpha-p, and r-b.');
    }

    return output;
  }

  pmfSingleValue(y, params, parametrization = this.parametrization) {
    if (y < 0) return NaN;

    
    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);

    if (alpha <= 0 || beta <= 0) return NaN;

    return Math.exp(lngamma(y + alpha)
                    - lngamma(alpha)
                    - lnfactorial(y)
                    + alpha * Math.log(beta / (1 + beta))
                    - y * Math.log(1 + beta));
  }

  cdfSingleValue(y, params, parametrization = this.parametrization) {
    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);

    if (alpha === 0 || beta === Infinity) return 1.0;
    if (alpha === Infinity) return y === Infinity ? 1.0 : 0.0; 

    if (y <= 0) return 0.0;
    if (y === Infinity) return 1.0;

    return regularizedIncompleteBeta(beta / (1 + beta), alpha, y + 1);
  }

  defaultXRange(params, parametrization = this.parametrization) {
    let [x1, x2] = super.ppf([0.001, 0.999], this.convertParamsToAlphaBeta(params, parametrization));

    
    if (x1 < (x2 - x1) / 10.0) x1 = -1.0;

    return [x1, x2];
  }

  
  quantileSet(x, p, extraParams) {
    if (this.fixedParams.length != 1) {
      throw new Error('Must have exactly one fixed parameter.')
    }

    let x1 = x[0];
    let p1 = p[0];
    let otherParam = extraParams[0];

    if (!Number.isInteger(x1)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0 ) {
      throw new Error('Must have ' + this.varName + ' > 0.')
    }

    const rootFun = (xi, x1, p1) => {
      if (this.fixedParamsInds[0] === 0) {
        return p1 - this.cdfSingleValue(x1, [otherParam, xi / (1 - xi)], this.parametrization);
      } else {
        return p1 - this.cdfSingleValue(x1, [xi / (1 - xi), otherParam], this.parametrization);        
      }
    }

    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [x1, p1]);
    let optimSuccess = xiOpt != null;
    
    return [[xiOpt / (1 - xiOpt)], optimSuccess];
  }

  quantileSetBoth(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    if (!Number.isInteger(x1) || !Number.isInteger(x2)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0 || x2 < 0) {
      throw new Error('Must have ' + this.varName + ' > 0.')
    }

    const quantileRootFun = (params, x1, p1, x2, p2) => {
      let mu = Math.exp(params[0]);
      let phi = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [mu, phi], 'mu-phi') - p1;
      let r2 = this.cdfSingleValue(x2, [mu, phi], 'mu-phi') - p2;

      return [r1, r2];
    };

    
    let meanp = (p1 + p2) / 2;
    let muGuess;
    if (Math.abs(meanp - 0.5) < 0.2) {
      let meanx = (x1 + x2) / 2;
      muGuess = meanx;
    }
    else {
      muGuess = 1.0;
    }

    let args = [x1, p1, x2, p2];
    let guess = [Math.log(muGuess), 1.0];
    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    let paramsOpt;
    if (optimSuccess) {
      let muOpt = Math.exp(logParams[0]);
      let phiOpt = Math.exp(logParams[1]);

      
      if (phiOpt > 1) {

        
        const muGivenPhi = (phi, x, p) => {
          dist = new NegativeBinomialDistribution('mu-phi');

          
          const rootFun = (xi, phi, x, p) => { 
            if (xi === 1) return p;
            if (xi === 0) return p - 1;
            return p - this.cdfSingleValue(x, [xi / (1 - xi), phi], 'mu-phi');
          }

          let xiOpt = brentSolve(rootFun, 0.0, 1.0, [phi, x, p]);
          let optimSuccess = xiOpt != null;
          
          return [xiOpt / (1 - xiOpt), optimSuccess];
        }

        const hitQuantiles = (phi, x1, p1, x2, p2) => {
          let [muAdj, rootFindSuccess] = muGivenPhi(phi, x2, p2);

          if (rootFindSuccess) {
            let [q1, q2] = this.ppf([p1, p2], [muAdj, phi], 'mu-phi');

            if (q1 === x1 && q2 === x2) return 1;
            else return -1;
          } else {
            return -1;
          }
        } 

        if (hitQuantiles(1.0) === 1) {
          phiOpt = 1.0;
          let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);
          muOpt = muAdj;
        }
        else {
          let phiAdj = bisectionSolve(hitQuantiles, 1.0, phiOpt, [x1, p1, x2, p2]);
          if (phiAdj != null) {
            phiOpt = phiAdj;
            let [muAdj, rootFindSuccess] = muGivenPhi(phiOpt, x2, p2);
            muOpt = muAdj;
          }
        }
      }

      paramsOpt = this.convertParams([muOpt, phiOpt], 'mu-phi', this.parametrization);
    } else { 
      let pois = new PoissonDistribution();
      let [paramsPois, optimSuccessPois] = pois.quantileSet([x2], [p2]);

      if (optimSuccessPois) {
        let poisQuants = pois.ppf([p1, p2], paramsPois);
        if (poisQuants[0] === x1 && poisQuants[1] === x2) {
          let errText;
          if (this.parametrization == 'alpha-beta'|| this.parametrization == 'alpha-p') {
            errText = 'Use Poisson (α → ∞ limit) with λ = ' + paramsPois[0].toPrecision(4);
          }
          else if (this.parametrization == 'mu-phi') {
            errText = 'Use Poisson (φ → ∞ limit) with λ = ' + paramsPois[0].toPrecision(4);
          }
          else if (this.parametrization == 'r-b') {
            errText = 'Use Poisson (r → ∞ limit) with λ = ' + paramsPois[0].toPrecision(4);
          }
          throw new Error(errText);
        }
        
      }
      paramsOpt = [];
    }

    return [paramsOpt, optimSuccess];
  }
}
""",
    "NegativeBinomialMuPhiDistribution": """
class NegativeBinomialMuPhiDistribution extends NegativeBinomialDistribution {
  constructor() {
    super('mu-phi');
  }
}
""",
    "NegativeBinomialAlphaPDistribution": """
class NegativeBinomialAlphaPDistribution extends NegativeBinomialDistribution {
  constructor() {
    super('alpha-p');
  }
}
""",
    "NegativeBinomialRBDistribution": """
class NegativeBinomialRBDistribution extends NegativeBinomialDistribution {
  constructor() {
    super('r-b');
  }
}
""",
    "PoissonDistribution": """
class PoissonDistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Poisson';

    
    this.varName = 'n';  

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['λ'];

    
    this.paramMin = [0.0];

    
    this.paramMax = [Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;
  }

  xMax(params) {
    return Infinity;
  }

  pmfSingleValue(n, params) {
    let lam = params[0];

    if (lam < 0) {
      return NaN;
    } else if (lam == 0) {
      if (n == 0) return 1.0;
      return 0.0;
    }

    return Math.exp(n * Math.log(lam) - lnfactorial(n) - lam);
  }

  cdfSingleValue(n, params) {
    if (n < 0) return 0.0;
    if (n === Infinity) return 1.0;

    let lam = params[0];

    if (lam === 0) return 1.0;

    return gammaincU(lam, n + 1, true);
  }

  defaultXRange(params) {
    return super.ppf([0.001, 0.999], params)
  }

  quantileSet(x, p) {
    let x1 = x[0];
    let p1 = p[0];

    if (!Number.isInteger(x1)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0) {
      throw new Error('Must have ' + this.varName + ' ≥ 0.')
    }

    
    if (x1 === 0 && p1 === 1) return [[0.0], true];

    
    const rootFun = (xi) => {
      if (xi === 1) return p1;
      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);
    }

    let xiOpt = brentSolve(rootFun, 0.0, 1.0);
    let optimSuccess = xiOpt != null;
    
    return [[xiOpt / (1 - xiOpt)], optimSuccess];
  }

}
""",
    "TelegraphRNADistribution": """
class TelegraphRNADistribution extends DiscreteUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Telegraph RNA';

    
    this.varName = 'n';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['kon', 'koff', 'beta'];

    
    this.paramMin = [0, 0, 0];

    
    this.paramMax = [Infinity, Infinity, Infinity];

    
    this.fixedParams = ['kon', 'koff'];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0;   
  }

  xMax(params) {
    return Infinity;
  }

  pmfSingleValue(n, params) {
    let kon = params[0];
    let koff = params[1];
    let beta = params[2];
    let result;

    
    if (beta == 0 || koff == 0) {
      result = n == 0 ? 1.0 : 0.0;
    }
    else if (n == 0) {
      result = hyp1f1(kon, kon + koff, -beta); 
    }
    else {
      
      let logpmf = n * Math.log(beta) - lnfactorial(n);

      
      logpmf += lngamma(kon + n) - lngamma(kon);
      logpmf -= lngamma(kon + koff + n) - lngamma(kon + koff);

      
      logpmf += Math.log(hyp1f1(kon + n, kon + koff + n, -beta));

      result = Math.exp(logpmf);
    }

    return result;
  }

  defaultXRange(params, parametrization = this.parametrization) {
    return [0.0, super.ppfSingleValue(0.999, params)];
  }

  quantileSet(x, p) {
    let x1 = x[0];
    let p1 = p[0];

    if (!Number.isInteger(x1)) {
      throw new Error(this.varName + ' must be integer.')
    }
    if (x1 < 0) {
      throw new Error('Must have ' + this.varName + ' > 0.')
    }

    
    if (x1 === 0 && p1 === 1) return [[0.0], true];

    
    const rootFun = (xi) => {
      if (xi === 1) return p1;
      return p1 - this.cdfSingleValue(x1, [xi / (1 - xi)]);
    }

    let xiOpt = brentSolve(rootFun, 0.0, 1.0);
    let optimSuccess = xiOpt != null;
    
    return [[xiOpt / (1 - xiOpt)], optimSuccess];
  }
}
""",
    "BetaDistribution": """
class BetaDistribution extends ContinuousUnivariateDistribution {
  constructor(parametrization = 'alpha-beta') {
    super(parametrization);

    
    this.name = 'Beta';

    
    this.varName = 'θ';

    
    this.hardMin = 0;
    this.hardMax = 1;

    
    if (this.parametrization === 'alpha-beta') {
      this.paramNames = ['α', 'β'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
    } else if (this.parametrization === 'phi-kappa') {
      this.paramNames = ['φ', 'κ'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [1.0, Infinity];
    } else { 
      this.paramNames = ['unnamedParam1', 'unnamedParam2'];
      this.paramMin = [0.0, 0.0];
      this.paramMax = [Infinity, Infinity];
    }

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0.0;
  }

  xMax(params) {
    return 1.0;
  }

  convertParams(params, from = this.parametrization, to = 'alpha-beta') {
    if (from === to) return params;
    else if (to === 'alpha-beta') return this.convertParamsToAlphaBeta(params, from);
    else if (from === 'alpha-beta') return this.convertParamsFromAlphaBeta(params, to);
    else return this.convertParamsFromAlphaBeta(this.convertParamsToAlphaBeta(params, from), to);
  }

  convertParamsToAlphaBeta(params, from = this.parametrization) {
    
    let alpha, beta;

    if (from === 'phi-kappa') {
      let [phi, kappa] = params.slice(0, 2);
      alpha = phi * kappa;
      beta = (1 - phi) * kappa;
    } else if (from === 'alpha-beta') {
      [alpha, beta] = params.slice(0, 2);
    } else {
      throw new Error('Invalid parametrization for converting. Allowed values are alpha-beta and phi-kappa');
    }

    return [alpha, beta];
  }

  convertParamsFromAlphaBeta(params, to = this.parametrization) {
    
    let [alpha, beta] = params.slice(0, 2);

    let output;
    if (to === 'phi-kappa') {
      let kappa = alpha + beta;
      let phi = alpha / kappa;
      output = [phi, kappa];
    } else if (to === 'alpha-beta') {
      output = [alpha, beta];
    } else {
      throw new Error('Invalid parametrization for converting. Allowed values are alpha-beta and phi-kappa.');
    }

    return output;
  }

  pdfSingleValue(x, params, parametrization = this.parametrization) {
    
    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);

    if (alpha <= 0 || beta <= 0) return NaN;

    if (x < 0 || x > 1) return NaN;

    if (iszero(x)) {
        if (alpha == 1) {
            return Math.exp(-lnbeta(alpha, beta));
        } else if (alpha > 1) {
            return 0.0;
        } else {
            return Infinity;
        }
    }
    else if (isone(x)) {
        if (beta == 1) {
            return Math.exp(-lnbeta(alpha, beta));
        }
        else if (beta > 1) {
            return 0.0;
        }
        else {
            return Infinity;
        }
    }

    let lnProb = (alpha - 1.0) * Math.log(x) + (beta - 1.0) * Math.log(1.0 - x) - lnbeta(alpha, beta);

    return Math.exp(lnProb);
  }

  cdfSingleValue(x, params, parametrization = this.parametrization) {
    
    let [alpha, beta] = this.convertParamsToAlphaBeta(params, parametrization);

    if (x <= 0) return 0.0;
    if (x >= 1) return 1.0;

    return regularizedIncompleteBeta(x, alpha, beta);
  }

  ppfSingleValue(p, params, parametrization = this.parametrization) {
    if (p == 0) return 0.0;
    if (p == 1) return 1.0;

    
    let rootFun = (x, params, p) => p - this.cdfSingleValue(x, params, parametrization);
    
    return brentSolve(rootFun, 0.0, 1.0, [params, p]);
  }

  quantileSet(x, p, parametrization = this.parametrization) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    
    const quantileRootFun = (params, x1, p1, x2, p2) => {
      let alpha = Math.exp(params[0]);
      let beta = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [alpha, beta], 'alpha-beta') - p1;
      let r2 = this.cdfSingleValue(x2, [alpha, beta], 'alpha-beta') - p2;

      return [r1, r2];
    };

    let args = [x1, p1, x2, p2];
    let guess = [1.0, 1.0];
    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    return [this.convertParamsFromAlphaBeta([Math.exp(logParams[0]), Math.exp(logParams[1])], this.parametrization), optimSuccess];
  }

  defaultXRange(params) {
    return [0.0, 1.0];
  }

}
""",
    "BetaPhiKappaDistribution": """
class BetaPhiKappaDistribution extends BetaDistribution {
  constructor() {
    super('phi-kappa');
  }
}
""",
    "CauchyDistribution": """
class CauchyDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Cauchy';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return -Infinity;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x == Infinity || x == -Infinity) return 0.0;

    let [mu, sigma] = params.slice(0, 2);

    return 1.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2))
  }

  cdfSingleValue(x, params) {
    let [mu, sigma] = params.slice(0, 2);

    return 0.5 + Math.atan((x - mu) / sigma) / Math.PI;
  }

  ppfSingleValue(p, params) {
    let [mu, sigma] = params.slice(0, 2);

    return mu + sigma * Math.tan(Math.PI * (p - 0.5));
  }

  defaultXRange(params) {
    
    return this.ppf([0.025, 0.975], params);
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    let cotp1 = 1.0 / Math.tan(Math.PI * p1);
    let cotp2 = 1.0 / Math.tan(Math.PI * p2);

    let mu = (x2 * cotp1 - x1 * cotp2) / (cotp1 - cotp2);
    let sigma = (x1 - x2) * Math.sin(Math.PI * p1) * Math.sin(Math.PI * p1) 
                / Math.sin(Math.PI * (p1 - p2));

    return [[mu, sigma], true];
  }
}
""",
    "ExponentialDistribution": """
class ExponentialDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Exponential';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['β'];

    
    this.paramMin = [0.0];

    
    this.paramMax = [Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0.0;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    let beta = params[0];

    if (x < 0) return NaN;
    if (x == Infinity) return 0.0;

    return beta * Math.exp(-beta * x);
  }

  cdfSingleValue(x, params) {
    let beta = params[0];

    if (x < 0) return 0.0;
    if (x == Infinity) return 0.0;

    return 1 - Math.exp(-beta * x);
  }

  ppfSingleValue(p, params) {
    let beta = params[0];

    if (p == 0) return 0.0;
    if (p == 1) return Infinity;

    return -Math.log(1.0 - p) / beta;
  }

  quantileSet(x, p) {
    let x1 = x[0];
    let p1 = p[0];

    let betaOptim;
    if (x1 == 0 || p1 == 1) {
      betaOptim = Infinity;
    }
    else {
      betaOptim = -Math.log(1.0 - p1) / x1
    }

    return [[betaOptim], true];
  }

  defaultXRange(params) {
    return [0.0, this.ppfSingleValue(0.999, params)];
  }

}
""",
    "GammaDistribution": """
class GammaDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Gamma';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['α', 'β'];

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0.0;   
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x < 0) return NaN;
    if (x == Infinity) return 0.0;

    let [alpha, beta] = params.slice(0, 2);

    if (x == 0) {
      if (alpha == 1) {
        return beta;
      } else if (alpha > 1) {
        return 0.0;
      } else {  
        return Infinity;
      }
    }

    let lnProb;
    lnProb = alpha * Math.log(beta * x) - Math.log(x) - beta * x - lngamma(alpha);

    return Math.exp(lnProb);
  }

  cdfSingleValue(x, params) {
    if (x <= 0) return 0.0;
    if (x == Infinity) return 1.0;

    let [alpha, beta] = params.slice(0, 2);

    return gammaincL(beta * x, alpha, true);
  }

  ppfSingleValue(p, params) {
    if (p === 0) return 0.0;
    if (p === 1) return Infinity;

    
    let rescaledParams = [params[0], 1.0];

    let rootFun = (xi, params, p) => {
        let x = xi == 1.0 ? Infinity : xi / (1.0 - xi);

        return p - this.cdfSingleValue(x, params);
    }

    let xiOpt = brentSolve(rootFun, 0.0, 1.0, [rescaledParams, p]);

    
    if (xiOpt === 1) {
      return Infinity;
    }

    
    let xFirstPass = xiOpt / (1.0 - xiOpt);

    let closeRootFun = (x, params, p) => {
      return p - this.cdfSingleValue(x, params);
    }

    let xOpt = secantSolve(xFirstPass, closeRootFun, [rescaledParams, p]);

    let retval;
    if (xOpt != null && closeRootFun(xOpt, rescaledParams, p) < closeRootFun(xFirstPass, rescaledParams, p)) {
      retval = xOpt;
    } else {
      retval = xFirstPass;
    }

    
    return retval / params[1];
 }

  defaultXRange(params) {
    let [x1, x2] = this.ppf([0.001, 0.999], params);

    
    if (x1 < (x2 - x1) / 10.0) x1 = 0.0;

    return [x1, x2];
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    
    let x1Rescaled = x1 / x2;
    let x2Rescaled = 1.0;

    
    const quantileRootFun = (params, x1, p1, x2, p2) => {
      let alpha = Math.exp(params[0]);
      let beta = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [alpha, beta]) - p1;
      let r2 = this.cdfSingleValue(x2, [alpha, beta]) - p2;

      return [r1, r2];
    };

    let args = [x1Rescaled, p1, x2Rescaled, p2];

    let guess = [0.75, 0.75];

    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    
    let paramsFirstPass = [Math.exp(logParams[0]), Math.exp(logParams[1])];

    
    if (!optimSuccess) {
      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];
    }

    
    const closeQuantileRootFun = (params, x1, p1, x2, p2) => {
      let r1 = this.cdfSingleValue(x1, params) - p1;
      let r2 = this.cdfSingleValue(x2, params) - p2;

      return [r1, r2];
    };

    let paramsOpt;
    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);

    let retval;
    if (optimSuccess && norm(closeQuantileRootFun(paramsOpt, x1, p1, x2, p2)) < norm(closeQuantileRootFun(paramsFirstPass, x1, p1, x2, p2))) {
      retval = paramsOpt;
    } else {
      retval = paramsFirstPass;
    }

    
    return [[retval[0], retval[1] / x2], optimSuccess];
  }

}
""",
    "HalfCauchyDistribution": """
class HalfCauchyDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'HalfCauchy';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = ['μ'];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return params[0];
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    let [mu, sigma] = params.slice(0, 2);

    if (x < mu) return NaN;
    if (x === Infinity) return 0.0;

    return 2.0 / Math.PI / sigma / (1 + Math.pow((x - mu) / sigma, 2));
  }

  cdfSingleValue(x, params) {
    let [mu, sigma] = params.slice(0, 2);

    if (x <= mu) return 0.0;
    if (x === Infinity) return 1.0;

    return 2.0 * Math.atan((x - mu) / sigma) / Math.PI;
  }

  ppfSingleValue(p, params) {
    let [mu, sigma] = params.slice(0, 2);

    return mu + sigma * Math.tan(Math.PI * p / 2.0);
  }

  defaultXRange(params) {
    
    return [params[0], this.ppf(0.9, params)];
  }

  quantileSet(x, p, extraParams) {
    let x1 = x[0];
    let p1 = p[0];
    let mu = extraParams[0];

    return [[(x1 - mu) / Math.tan(Math.PI * p1 / 2)], true];
  }
}
""",
    "HalfNormalDistribution": """
class HalfNormalDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'HalfNormal';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = ['μ'];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return params[0];
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    let [mu, sigma] = params.slice(0, 2);

    if (x < mu) return NaN;
    if (x === Infinity) return 0.0;

    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));
    return Math.exp(-expTerm) / sigma * Math.sqrt(2.0 / Math.PI);
  }

  cdfSingleValue(x, params) {
    let [mu, sigma] = params.slice(0, 2);

    if (x <= mu) return 0.0;
    if (x === Infinity) return 1.0;

    return erf((x - mu) / sigma / Math.sqrt(2));
  }

  ppfSingleValue(p, params) {
    let [mu, sigma] = params.slice(0, 2);
    let sqrt2 = 1.4142135623730951;

    return mu + sqrt2 * sigma * erfinv(p);
  }

  defaultXRange(params) {
    return [params[0], this.ppf(0.999, params)];
  }

  quantileSet(x, p, extraParams) {
    let x1 = x[0];
    let p1 = p[0];
    let mu = extraParams[0];

    let sqrt2 = 1.4142135623730951;

    return [[(x1 - mu) / sqrt2 / erfinv(p1)], true];
  }
}
""",
    "HalfStudentTDistribution": """
class HalfStudentTDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'HalfStudentT';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['ν', 'μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = ['ν', 'μ'];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return params[1];
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    let [nu, mu, sigma] = params.slice(0, 3);

    if (x < mu) return NaN;
    if (x === Infinity) return 0.0;

    let lnprob;

    lnprob = Math.log(2.0) + lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 
             - Math.log(sigma) - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));

    return Math.exp(lnprob);
  }

  cdfSingleValue(x, params) {
    let [nu, mu, sigma] = params.slice(0, 3);

    if (x <= mu) return 0.0;
    if (x === Infinity) return 1.0;

    let y = (x - mu) / sigma;

    return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5);
  }

  ppfSingleValue(p, params) {
    if (p === 0) return params[1];
    if (p === 1) return Infinity;

    let studentT = new StudentTDistribution();
    return studentT.ppf((1 + p) / 2, params);
  }

  defaultXRange(params) {
    
    let [nu, mu, sigma] = params.slice(0, 3);
    let p2;

    if (nu < 2) p2 = 0.95;
    else if (nu < 4) p2 = 0.99;
    else if (nu < 10) p2 = 0.995;
    else p2 = 0.999;

    return [params[1], this.ppf(p2, params)];
  }

  quantileSet(x, p, extraParams) {
    let [nu, mu] = extraParams;

    
    if (nu === 1) { 
      let halfCauchy = new HalfCauchyDistribution();
      return halfCauchy.quantileSet(x, p, [mu]);
    }
    if (nu === Infinity) { 
      let halfNormal = new HalfNormalDistribution();
      return halfNormal.quantileSet(x, p, [mu]);
    }

    let x1 = x[0];
    let p1 = p[0];

    
    const quantileRootFun = (params, nu, mu, x1, p1) => {
      let sigma = Math.exp(params[0]);

      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];
    };

    let args = [nu, mu, x1, p1];

    
    let guess;
    let guessSuccess;
    if (nu < 3) {
      let halfCauchy = new HalfCauchyDistribution();
      [guess, guessSuccess] = halfCauchy.quantileSet(x, p, [mu]);
    } else {
      let halfNormal = new HalfNormalDistribution();
      [guess, guessSuccess] = halfNormal.quantileSet(x, p, [mu]);      
    }

    
    guess = [Math.log(guess[0])];

    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    
    paramsFirstPass[0] = Math.exp(paramsFirstPass[0]);

    
    if (!optimSuccess) {
      return [[paramsFirstPass[0]], optimSuccess];
    }

    
    const closeQuantileRootFun = (params, nu, mu, x1, p1) => {
      let sigma = params[0];

      return [this.cdfSingleValue(x1, [nu, mu, sigma]) - p1];
    };

    let paramsOpt;
    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);

    let retval;
    if (optimSuccess && norm(closeQuantileRootFun(paramsOpt, nu, x1, p1)) < norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1))) {
      retval = [paramsOpt, optimSuccess];
    } else {
      retval = [paramsOpt, optimSuccess];
    }

    return retval;
  }
}
""",
    "InverseGammaDistribution": """
class InverseGammaDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'InverseGamma';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['α', 'β'];

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0.0;   
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x < 0) return NaN;
    if (x === 0 || x === Infinity) return 0.0;

    let [alpha, beta] = params.slice(0, 2);

    let lnProb;
    lnProb = alpha * Math.log(beta) - (alpha + 1) * Math.log(x) - beta / x - lngamma(alpha);

    return Math.exp(lnProb);
  }

  cdfSingleValue(x, params) {
    if (x <= 0) return 0.0;
    if (x == Infinity) return 1.0;

    let [alpha, beta] = params.slice(0, 2);

    return gammaincU(beta / x, alpha, true);
  }

  ppfSingleValue(p, params) {
    if (p === 0) return 0.0;
    if (p === 1) return Infinity;

    let gamma = new GammaDistribution();
    return 1.0 / gamma.ppf(1.0 - p, params);
  }

  defaultXRange(params) {
    
    let [x1, x2] = this.ppf([0.001, 0.99], params);

    
    if (x1 < (x2 - x1) / 10.0) x1 = 0.0;

    return [x1, x2];
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);

    let gamma = new GammaDistribution();
    return gamma.quantileSet([1.0 / x2, 1.0 / x1], p);
  }

}
""",
    "InverseGaussianDistribution": """
class InverseGaussianDistribution extends ContinuousUnivariateDistribution {
  
  
  constructor() {
    super();

    
    this.name = 'InverseGaussian';

    
    this.varName = 'y';

    
    this.hardMin = 0.0;
    this.hardMax = Infinity;

    
    this.paramNames = ['µ', 'λ'];

    
    this.locationParam = undefined;

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params, parametrization = this.parametrization) {
    return 0.0;    
  }

  xMax(params, parametrization = this.parametrization) {
    return Infinity;
  }

  pdfSingleValue(x, params, parametrization = this.parametrization) {
    if (x < 0) return NaN;
    if (x === 0 || x === Infinity) return 0.0;  

    let [mu, lambda] = params.slice(0, 2);

    let lnProb;
    lnProb = -Math.log(2.0 * Math.PI) / 2.0 + (Math.log(lambda) - 3.0 * Math.log(x)) / 2.0
             - lambda * Math.pow(x - mu, 2) / (2.0 * Math.pow(mu, 2) * x);

    return Math.exp(lnProb);
  }

  cdfSingleValue(x, params, parametrization = this.parametrization) {
    if (x <= 0) return 0.0;
    if (x === Infinity) return 1.0;

    let [mu, lambda] = params.slice(0, 2);

    let term1 = lnStdNormCdf(Math.sqrt(lambda / x) * (x / mu - 1.0));
    let term2 = 2.0 * lambda / mu + lnStdNormCdf(-Math.sqrt(lambda / x) * (x / mu + 1.0));

    return Math.exp(logSumExp(term1, term2));
  }

  ppfSingleValue(p, params, parametrization = this.parametrization) {
    
    if (p == 0) return 0.0;
    if (p == 1) return Infinity;

    let [mu, lambda] = params.slice(0, 2);

    
    let xMode = mu * (Math.sqrt(1.0 + 2.25 * Math.pow(mu, 2) / Math.pow(lambda, 2)) - 1.5 * mu / lambda);

    
    let f;
    let df;
    if (p < this.cdfSingleValue(xMode, params, parametrization)) {
      f = (x, params, p) => this.cdfSingleValue(x, params, parametrization) - p;
      df = (x, params, p) => this.pdfSingleValue(x, params, parametrization);
    }
    else {
      f = (x, params, p) => p - this.cdfSingleValue(x, params, parametrization);
      df = (x, params, p) => -this.pdfSingleValue(x, params, parametrization);
    }

    return newtonSolve(xMode, f, df, [params, p]);
  }

  defaultXRange(params, parametrization = this.parametrization) {
    
    let [x1, x2] = this.ppf([0.01, 0.99], params);

    
    if (x1 < (x2 - x1) / 10.0) x1 = 0.0;

    return [x1, x2];    
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    
    let x1Rescaled = x1 / x2;
    let x2Rescaled = 1.0;

    
    const quantileRootFun = (params, x1, p1, x2, p2) => {
      let mu = Math.exp(params[0]);
      let lambda = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [mu, lambda]) - p1;
      let r2 = this.cdfSingleValue(x2, [mu, lambda]) - p2;

      return [r1, r2];
    };

    let args = [x1Rescaled, p1, x2Rescaled, p2];

    let guess = [2, 2];

    let [logParams, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    
    let paramsOpt = [Math.exp(logParams[0]), Math.exp(logParams[1])];

    
    return [[x2 * paramsOpt[0], x2 * paramsOpt[1]], optimSuccess];
  }
}
""",
    "LogNormalDistribution": """
class LogNormalDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'LogNormal';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
}

  xMin(params) {
    return 0.0;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x < 0.0) return NaN;
    if (x === 0) return 0.0;
    if (x === Infinity) return 0.0;

    let [mu, sigma] = params.slice(0, 2);
    let expTerm = (Math.pow(Math.log(x) - mu, 2) / 2.0 / Math.pow(sigma, 2))
    return Math.exp(-expTerm) / x / sigma / Math.sqrt(2 * Math.PI);
  }

  cdfSingleValue(x, params) {
    if (x <= 0) return 0.0;
    if (x === Infinity) return 1.0;

    let [mu, sigma] = params.slice(0, 2);
    return (1 + erf((Math.log(x) - mu) / sigma / Math.sqrt(2))) / 2;
  }

  ppfSingleValue(p, params) {
    if (p === 0) return 0.0;
    if (p === 1) return Infinity;

    let [mu, sigma] = params.slice(0, 2);
    let sqrt2 = 1.4142135623730951;

    return Math.exp(mu + sqrt2 * sigma * erfinv(2 * p - 1));
  }

  defaultXRange(params) {
    
    let [x1, x2] = this.ppf([0.01, 0.99], params);

    
    if (x1 < (x2 - x1) / 10.0) x1 = 0.0;

    return [x1, x2];
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);
    let [logx1, logx2] = [Math.log(x1), Math.log(x2)];

    let sqrt2 = 1.4142135623730951;

    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);
    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);

    let sigma = (logx2 - logx1) / (sigmaCoeff2 - sigmaCoeff1);
    let mu = logx2 - sigmaCoeff2 * sigma;

    return [[mu, sigma], true];
  }
}
""",
    "NormalDistribution": """
class NormalDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Normal';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
}

  xMin(params) {
    return -Infinity;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x === -Infinity || x === Infinity) return 0.0;

    let [mu, sigma] = params.slice(0, 2);

    let expTerm = (Math.pow(x - mu, 2) / 2.0 / Math.pow(sigma, 2));
    return Math.exp(-expTerm) / sigma / Math.sqrt(2 * Math.PI);
  }

  cdfSingleValue(x, params) {
    if (x === -Infinity) return 0.0;
    if (x === Infinity) return 1.0;

    let [mu, sigma] = params.slice(0, 2);

    return (1 + erf((x - mu) / sigma / Math.sqrt(2))) / 2;
  }

  ppfSingleValue(p, params) {
    if (p === 0) return -Infinity;
    if (p === 1) return Infinity;

    let [mu, sigma] = params.slice(0, 2);
    let sqrt2 = 1.4142135623730951;

    return mu + sqrt2 * sigma * erfinv(2 * p - 1);
  }

  defaultXRange(params) {
    return this.ppf([0.001, 0.999], params);
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    let sqrt2 = 1.4142135623730951;

    let sigmaCoeff1 = sqrt2 * erfinv(2 * p1 - 1);
    let sigmaCoeff2 = sqrt2 * erfinv(2 * p2 - 1);

    let sigma = (x2 - x1) / (sigmaCoeff2 - sigmaCoeff1);
    let mu = x2 - sigmaCoeff2 * sigma;

    return [[mu, sigma], true];
  }
}
""",
    "ParetoDistribution": """
class ParetoDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Pareto';

    
    this.varName = 'y';

    
    this.hardMin = 0;
    this.hardMax = Infinity;

    
    this.paramNames = ['yₘᵢₙ', 'α'];

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return params[0];    
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    let [ymin, alpha] = params.slice(0, 2);

    if (x < ymin) return NaN;
    if (x === Infinity) return 0.0;

    let logp = Math.log(alpha) + alpha * Math.log(ymin) - (alpha + 1) * Math.log(x); 
    return Math.exp(logp);
  }

  cdfSingleValue(x, params) {
    let [ymin, alpha] = params.slice(0, 2);

    if (x <= ymin) return 0.0;
    if (x === Infinity) return 1.0;

    return 1 - Math.pow(ymin / x, alpha);
  }

  ppfSingleValue(p, params) {
    let [ymin, alpha] = params.slice(0, 2);

    if (p === 0) return ymin;
    if (p === 1) return Infinity;

    return ymin * Math.pow(1.0 / (1.0 - p), 1.0 / alpha);
  }

  defaultXRange(params) {
    
    let [ymin, alpha] = params.slice(0, 2);

    let p = 0.01;

    let x1 = ymin;
    let logx2 = Math.log(ymin) - Math.log(p) / (1 + alpha);
    let x2 = Math.exp(logx2);

    return [x1, x2];
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    let alpha = (Math.log(1.0 - p1) - Math.log(1.0 - p2)) / (Math.log(x2) - Math.log(x1));
    let ymin = Math.exp(Math.log(1 - p2) / alpha + Math.log(x2));

    return [[ymin, alpha], true];
  }
}
""",
    "StudentTDistribution": """
class StudentTDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'StudentT';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['ν', 'μ', 'σ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [0.0, -Infinity, 0.0];

    
    this.paramMax = [Infinity, Infinity, Infinity];

    
    this.fixedParams = ['ν'];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return -Infinity;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x === -Infinity || x === Infinity) return 0.0;

    let [nu, mu, sigma] = params.slice(0, 3);

    let lnprob;

    lnprob = lngamma((nu + 1) / 2) - lngamma(nu / 2) - Math.log(Math.PI * nu) / 2 - Math.log(sigma)
             - (nu + 1) / 2 * log1p(Math.pow(x - mu, 2) / nu / Math.pow(sigma, 2));

    return Math.exp(lnprob);
  }

  cdfSingleValue(x, params) {
    if (x === -Infinity) return 0.0;
    if (x === Infinity) return 1.0;

    let [nu, mu, sigma] = params.slice(0, 3);

    let y = (x - mu) / sigma;

    if (y >= 0) {
        return 1 - regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;
    }
    else {
        return regularizedIncompleteBeta(nu / (Math.pow(y, 2) + nu), 0.5 * nu, 0.5) / 2;        
    }
  }

  ppfSingleValue(p, params) {
    let [nu, mu, sigma] = params.slice(0, 3);

    
    let guess;
    if (nu < 3) { 
      guess = Math.tan(Math.PI * (p - 0.5));
    } else {
      guess = Math.sqrt(2) * erfinv(2 * p - 1)
    }

    
    if (nu === 1 || nu === Infinity) return mu + sigma * guess;

    
    let rootFun = (x, nu, p) => [p - this.cdfSingleValue(x, [nu, 0, 1])];
    let [xOpt, success] = findRootTrustRegion(rootFun, [guess], [nu, p]);

    return mu + sigma * xOpt[0];
  }

  defaultXRange(params) {
    
    let [nu, mu, sigma] = params.slice(0, 3);

    let p1;
    let p2;

    if (nu < 2) {
        p1 = 0.05;
        p2 = 0.95;
    }
    if (nu < 4) {
        p1 = 0.01;
        p2 = 0.99;
    }
    else if (nu < 10) {
        p1 = 0.005;
        p2 = 0.995;
    }
    else {
        p1 = 0.001;
        p2 = 0.999;
    }

    return this.ppf([p1, p2], params);
  }

  quantileSet(x, p, extraParams) {

    let nu = extraParams[0];

    
    if (nu === 1) { 
      let cauchy = new CauchyDistribution();
      return cauchy.quantileSet(x, p);
    }
    if (nu === Infinity) { 
      let normal = new NormalDistribution();
      return normal.quantileSet(x, p);
    }

    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    
    const quantileRootFun = (params, nu, x1, p1, x2, p2) => {
      let mu = params[0];
      let sigma = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;
      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;

      return [r1, r2];
    };

    let args = [nu, x1, p1, x2, p2];

    
    let guess;
    let guessSuccess;
    if (nu < 3) {
      let cauchy = new CauchyDistribution();
      [guess, guessSuccess] = cauchy.quantileSet(x, p);
    } else {
      let normal = new NormalDistribution();
      [guess, guessSuccess] = normal.quantileSet(x, p);      
    }

    
    guess = [guess[0], Math.log(guess[1])];

    let [paramsFirstPass, optimSuccess] = findRootTrustRegion(quantileRootFun, guess, args=args);

    
    paramsFirstPass[1] = Math.exp(paramsFirstPass[1]);

    
    if (!optimSuccess) {
      return [[paramsFirstPass[0], paramsFirstPass[1]], optimSuccess];
    }

    
    const closeQuantileRootFun = (params, nu, x1, p1, x2, p2) => {
      let [mu, sigma] = params.slice(0, 2);

      let r1 = this.cdfSingleValue(x1, [nu, mu, sigma]) - p1;
      let r2 = this.cdfSingleValue(x2, [nu, mu, sigma]) - p2;

      return [r1, r2];
    };

    let paramsOpt;
    [paramsOpt, optimSuccess] = findRootTrustRegion(closeQuantileRootFun, paramsFirstPass, args=args);

    let retval;
    if (optimSuccess && norm(closeQuantileRootFun(paramsOpt, nu, x1, p1, x2, p2)) < norm(closeQuantileRootFun(paramsFirstPass, nu, x1, p1, x2, p2))) {
      retval = [paramsOpt, optimSuccess];
    } else {
      retval = [paramsOpt, optimSuccess];
    }

    return retval;
  }

}
""",
    "UniformDistribution": """
class UniformDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Uniform';

    
    this.varName = 'y';

    
    this.hardMin = -Infinity;
    this.hardMax = Infinity;

    
    this.paramNames = ['α', 'β'];

    
    this.paramMin = [-Infinity, -Infinity];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return params[0];    
  }

  xMax(params) {
    return params[1];    
  }

  pdfSingleValue(x, params) {
    let [alpha, beta] = params.slice(0, 2);
    
    if (beta <= alpha || x < alpha || x > beta) return NaN;

    return 1.0 / (beta - alpha);
  }

  cdfSingleValue(x, params) {
    let [alpha, beta] = params.slice(0, 2);

    if (beta <= alpha) return NaN;

    if (x <= alpha) return 0.0;
    if (x >= beta) return 1.0;

    return (x - alpha) / (beta - alpha);
  }

  ppfSingleValue(p, params) {
    let [alpha, beta] = params.slice(0, 2);

    if (beta <= alpha) return NaN;

    return alpha + p * (beta - alpha);
  }

  defaultXRange(params) {
    let [alpha, beta] = params.slice(0, 2);

    if (beta <= alpha) return [0, 1];

    let d = beta - alpha;
    
    return[alpha - d * 0.1, beta + d * 0.1];
  }

  quantileSet(x, p, extraParams = []) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    let alpha = (p2 * x1 - p1 * x2) / (p2 - p1);
    let beta = alpha + (x2 - x1) / (p2 - p1);

    return [[alpha, beta], true];
  }
}
""",
    "VonMisesDistribution": """
class VonMisesDistribution extends ContinuousUnivariateDistribution {
  
  
  constructor() {
    super();

    
    this.name = 'Von Mises';

    
    this.varName = 'y';

    
    this.hardMin = -Math.PI;
    this.hardMax = Math.PI;

    
    this.paramNames = ['μ', 'κ'];

    
    this.locationParam = 'μ';

    
    this.paramMin = [-Math.PI, 0.0];

    
    this.paramMax = [Math.PI, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds();

    
    super.generateLocationParamIndex();
  }

  xMin(params) {
    return this.hardMin;
  }

  xMax(params) {
    return this.hardMax;
  }

  pdfSingleValue(x, params) {
    let [mu, kappa] = params.slice(0, 2);

    return Math.exp(kappa * cosm1(x - mu)) / (2 * Math.PI * besseli0(kappa, true));
  }

  cdfSingleValueNormalApprox(x, params) {
    
    let [mu, kappa] = params.slice(0, 2);
    let sigma = 1.0 / Math.sqrt(kappa);
    let twopi = 2.0 * Math.PI;

    let normal = new NormalDistribution();
    let result = normal.cdfSingleValue(x, [mu - twopi, sigma]);
    result -= normal.cdfSingleValue(-Math.PI, [mu - twopi, sigma]);
    result += normal.cdfSingleValue(x, [mu, sigma]);
    result -= normal.cdfSingleValue(-Math.PI, [mu, sigma]);
    result += normal.cdfSingleValue(x, [mu + twopi, sigma]);
    result -= normal.cdfSingleValue(-Math.PI, [mu + twopi, sigma]);

    return result
  }

  cdfSingleValue(x, params) {
    let [mu, kappa] = params.slice(0, 2);
    let result;

    if (isclose(x, this.hardMin)) result = 0;
    else if (isclose(x, this.hardMax)) result = 1;
    else if (kappa > 50) {
      result = this.cdfSingleValueNormalApprox(x, params);
    } else {
      
      let nChebPoints = 100;

      let f = (x) => this.pdfSingleValue(x, params);
      result = clenshawCurtisIntegrate(f, this.hardMin, x, nChebPoints);
    }

    return result;
  }

  
  cdfSingleValueForMu0(x, params) {
    let [mu, kappa] = params.slice(0, 2);

    if (!isclose(mu, 0)) {
      throw new Error("cdfSingleValueFor Mu0 only works for μ = 0.")
    }

    let vonMisesSeries = (k, y, p) => {
      let s = Math.sin(y);
      let c = Math.cos(y);
      let sn = Math.sin(p * y);
      let cn = Math.cos(p * y);
      let R = 0;
      let V = 0;

      for (let n = p - 1; n > 0; n--) {
        [sn, cn] = [sn * c - cn * s, cn * c + sn * s];
        R = 1.0 / (2 * n / k + R);
        V = R * (sn / n + V);
      }

      return 0.5 + y / (2 * Math.PI) + V / Math.PI;
    } 

    let vonMisesNormalApprox = (k, y) => {
      let b = Math.sqrt(2 * Math.PI) / besseli0(k, true);
      let z = b * Math.sin(y / 2.0)

      return (1 + erf(z / Math.sqrt(2))) / 2;
    }

    
    let y = x - mu;

    
    let iy = Math.round(y / (2.0 * Math.PI))
    y -= iy * (2 * Math.PI)

    
    let CK = 50;
    let [a1, a2, a3, a4] = [28.0, 0.5, 100.0, 5.0];

    
    let result;
    if (kappa >= CK) result = vonMisesNormalApprox(kappa, y);
    else {
    let p = Math.floor(1 + a1 + a2 * kappa - a3 / (kappa + a4));
        result = vonMisesSeries(kappa, y, p)
        result = result < 0 ? 0 : result > 1 ? 1 : result;
    }

    return result;
  }

  ppfSingleValue(p, params) {
    if (p == 0) return 0.0;
    if (p == 1) return 2.0 * Math.PI;

    
    let rootFun = (x, params, p) => p - this.cdfSingleValue(x, params);
    
    let result = brentSolve(rootFun, this.hardMin, this.hardMax, [params, p]);

    if (result === null) return 0.0;
    else return result;
  }

  defaultXRange(params) {
    return [this.hardMin, this.hardMax];
  }

  quantileSet(x, p) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    if (x1 <= -Math.PI || x1 >= Math.PI || x2 <= -Math.PI || x2 >= Math.PI) {
      throw new Error("lower and upper " + this.varName + " must be in interval (-π and π).")
    }

    
    const quantileRootFun = (params, x1, p1, x2, p2) => {
      
      let mu = Math.PI * (2 / (1 + Math.exp(-params[0])) - 1);
      let kappa = Math.exp(params[1]);

      let r1 = this.cdfSingleValue(x1, [mu, kappa]) - p1;
      let r2 = this.cdfSingleValue(x2, [mu, kappa]) - p2;

      return [r1, r2];
    };

    
    let normal = new NormalDistribution();
    let [paramsOpt, optimSuccess] = normal.quantileSet(x, p);
    let [muGuess, sigmaGuess] = paramsOpt;
    let guess;
    if (optimSuccess && muGuess > -Math.PI && muGuess < Math.PI) {
      guess = [Math.log((Math.PI + muGuess) / (Math.PI - muGuess)), -2 * Math.log(sigmaGuess)];
    }
    else {
      guess = [0.0, 0.0];
    }

    
    let args = [x1, p1, x2, p2];
    [paramsOpt, optimSuccess] = findRootTrustRegion(
      quantileRootFun, 
      guess, 
      args, 
      jacCentralDiff,
      0.00001,  
      1000      
    );
    paramsOpt = [Math.PI * (2 / (1 + Math.exp(-paramsOpt[0])) - 1), Math.exp(paramsOpt[1])];

    return [paramsOpt, optimSuccess];
  }
}
""",
    "WeibullDistribution": """
class WeibullDistribution extends ContinuousUnivariateDistribution {
  constructor() {
    super();

    
    this.name = 'Weibull';

    
    this.varName = 'y';

    
    this.hardMin = 0.0;
    this.hardMax = Infinity;

    
    this.paramNames = ['α', 'σ'];

    
    this.paramMin = [0.0, 0.0];

    
    this.paramMax = [Infinity, Infinity];

    
    this.fixedParams = [];

    
    super.generateActiveFixedInds()
  }

  xMin(params) {
    return 0.0;
  }

  xMax(params) {
    return Infinity;
  }

  pdfSingleValue(x, params) {
    if (x < 0) return NaN;
    if (x === Infinity) return 0.0;

    let [alpha, sigma] = params.slice(0, 2);

    if (x === 0) {
      if (alpha > 1.0) return 0.0;
      if (alpha < 1.0) return Infinity;
      if (alpha == 1.0) return Math.exp(-x / sigma) / sigma;
    }


    let logp = -Math.pow(x / sigma, alpha) + (alpha - 1) * Math.log(x) 
                + Math.log(alpha) - alpha * Math.log(sigma);

    return Math.exp(logp);
  }

  cdfSingleValue(x, params) {
    if (x <= 0) return 0.0;
    if (x === Infinity) return 1.0;

    let [alpha, sigma] = params.slice(0, 2);

    return 1 - Math.exp(-Math.pow(x / sigma, alpha));
  }

  ppfSingleValue(p, params) {
    if (p === 0) return 0.0;
    if (p === 1) return Infinity;

    let [alpha, sigma] = params.slice(0, 2);

    return sigma * Math.pow(-Math.log(1.0 - p), 1.0 / alpha);
  }

  defaultXRange(params) {
    let [x1, x2] = this.ppf([0.001, 0.999], params);

    
    if (x1 < (x2 - x1) / 10.0) x1 = 0.0;

    return [x1, x2];
  }

  quantileSet(x, p, extraParams = []) {
    let [x1, x2] = x.slice(0, 2);
    let [p1, p2] = p.slice(0, 2);

    let loglog1 = Math.log(-Math.log(1.0 - p1));
    let loglog2 = Math.log(-Math.log(1.0 - p2));
    let logx1 = Math.log(x1);
    let logx2 = Math.log(x2);

    let alpha = (loglog2 - loglog1) / (logx2 - logx1);
    let sigma = Math.exp(logx2 - loglog2 / alpha);

    return [[alpha, sigma], true];
  }

  
}
""",
    "isclose": """
function isclose(x, y, rtol = 1.0e-7, atol = 1.0e-8) {
  return Math.abs(x - y) <= (atol + rtol * Math.abs(y));
}

""",
    "isone": """
function isone(x, rtol = 1.0e-5, atol = 1.0e-8) {
  return isclose(x, 1.0, rtol, atol);
}

""",
    "iszero": """
function iszero(x, eps = 1.0e-8) {
  return Math.abs(x) <= eps;
}

""",
    "logspace": """
function logspace(start, stop, n) {
  let x = new Array(n);
  let step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) {
    x[i] = Math.pow(10, start + i * step);
  }

  return x;
}

""",
    "linspace": """
function linspace(start, stop, n) {
  let x = new Array(n);
  let step = (stop - start) / (n - 1);
  for (let i = 0; i < n; i++) {
    x[i] = start + i * step;
  }

  return x;
}

""",
    "arange": """
function arange(start, stop) {
  let x = new Array(stop - start);
  for (let i = 0; i < stop - start; i++) {
    x[i] = start + i;
  }

  return x;
}

""",
    "meshgrid": """
function meshgrid(x, y) {
  let m = y.length;
  let n = x.length;

  let xGrid = new Array(m);
  let yGrid = new Array(m);

  for (let i = 0; i < m; i++) {
    xGrid[i] = new Array(n);
    yGrid[i] = new Array(n);
    for (let j = 0; j < n; j++) {
      xGrid[i][j] = x[j];
      yGrid[i][j] = y[i];
    }
  }

  return [xGrid, yGrid];
}

""",
    "logit": """
function logit(x) {
  if (x == 0) return -Infinity;

  if (x == 1) return Infinity;

  if (x < 0 || x > 1) return NaN;

  return Math.log(x / (1.0 - x));
}

""",
    "log1p": """
function log1p(x) {
  
  
  if (x <= -1.0) {
    throw new RangeError('Argument must be greater than -1.0');
  }

  
  else if (Math.abs(x) > 1e-4) {
    return Math.log(1.0 + x);
  }

  else {
    return (-0.5*x + 1.0)*x;
  }
}

""",
    "logSumExp": """
function logSumExp(x1, x2) {
  if (x1 > x2) {
    return x1 + log1p(Math.exp(x2 - x1));
  }
  else {
    return x2 + log1p(Math.exp(x1 - x2));
  }
}

""",
    "erf": """
function erf(x) {
  
  var a = [1.00002368,
           0.37409196,
           0.09678418,
           -0.18628806,
           0.27886807,
           -1.13520398,
           1.48851587,
           -0.82215223,
           0.17087277];

  var t = 1 / (1 + Math.abs(x)/2);
  var expSum = -Math.pow(x, 2) - 1.26551223;

  for (var i = 0; i < a.length; i++) {
      expSum += a[i] * Math.pow(t, i+1);
  }

  var result = 1 - t * Math.exp(expSum);

  if (x < 0) return -result;
  return result;
}

""",
    "erfc": """
function erfc(x) {
  let y2 = Math.pow(x, 2);
  let y = x < 0 ? -x : x;
  const term1 = 0.56418958354775629 / (y + 2.06955023132914151);
  
  const term2 = (y**2 + 2.71078540045147805 * y + 5.80755613130301624) / 
                (y**2 + 3.47954057099518960 * y + 12.06166887286239555);

  const term3 = (y**2 + 3.47469513777439592 * y + 12.07402036406381411) / 
                (y**2 + 3.72068443960225092 * y + 8.44319781003968454);

  const term4 = (y**2 + 4.00561509202259545 * y + 9.30596659485887898) / 
                (y**2 + 3.90225704029924078 * y + 6.36161630953880464);

  const term5 = (y**2 + 5.16722705817812584 * y + 9.12661617673673262) / 
                (y**2 + 4.03296893109262491 * y + 5.13578530585681539);

  const term6 = (y**2 + 5.95908795446633271 * y + 9.19435612886969243) / 
                (y**2 + 4.11240942957450885 * y + 4.48640329523408675);

  const expTerm = Math.exp(-Math.pow(x,2));

  let res = term1 * term2 * term3 * term4 * term5 * term6 * expTerm;

  return x < 0 ? 2.0 - res : res;
}

""",
    "erfinv": """
function erfinv(x) {
  
  let p = (x + 1.0) / 2.0;

  
  if (p == 0.0) return -Infinity;
  if (p == 1.0) return Infinity;
  if (p > 1.0 || p < 0.0) return undefined;

  let split1 = 0.425;
  let split2 = 5.0;
  let const1 = 0.180625;
  let const2 = 1.6;

  
  let a0 = 3.3871327179;
  let a1 = 5.0434271938e1;
  let a2 = 1.5929113202e2;
  let a3 = 5.9109374720e1;
  let b1 = 1.7895169469e1;
  let b2 = 7.8757757664e1;
  let b3 = 6.7187563600e1;

  
  let c0 = 1.4234372777;
  let c1 = 2.7568153900;
  let c2 = 1.3067284816;
  let c3 = 1.7023821103e-1;
  let d1 = 7.3700164250e-1;
  let d2 = 1.2021132975e-1;

  
  let e0 = 6.6579051150;
  let e1 = 3.0812263860;
  let e2 = 4.2868294337e-1;
  let e3 = 1.7337203997e-2;
  let f1 = 2.4197894225e-1;
  let f2 = 1.2258202635e-2;

  let r;
  let res;
  let q = p - 0.5;

  if (Math.abs(q) <= split1) {
    r = const1 - q * q;
    res = q * (((a3 * r + a2) * r + a1) * r + a0) /
              (((b3 * r + b2) * r + b1) * r + 1.0);
  } else {
    r = q < 0 ? p : 1.0 - p;

    r = Math.sqrt(-Math.log(r));

    if (r <= split2) {
      r -= const2;
      res = (((c3 * r + c2) * r + c1) * r + c0) /
             ((d2 * r + d1) * r + 1.0);
    } else {
      r -= split2;
      res = (((e3 * r + e2) * r + e1) * r + e0) /
             ((f2 * r + f1) * r + 1.0);
    }
  
    if (q < 0) {
      res = -res;
    }
  }

  
  return 0.7071067811865475 * res;

}

""",
    "lnStdNormCdf": """
function lnStdNormCdf(x) {
  
  let y = x / 1.4142135623730950488016887;

  let res;
  
  if (y > 0.0) {
    res = log1p(-0.5 * erfc(y));
  } 
  else if (y > -20.0) {
    
    res = Math.log(erfc(-y)) - 0.6931471805599453;
  }
  else {
    
    const y2 = Math.pow(y, 2);
    const y4 = Math.pow(y, 4);
    const y6 = Math.pow(y, 6);
    const y8 = Math.pow(y, 8);
    const y10 = Math.pow(y, 10);
    const temp_p = 0.000658749161529837803157 + 0.0160837851487422766278 / y2
                 + 0.125781726111229246204 / y4 + 0.360344899949804439429 / y6
                 + 0.305326634961232344035 / y8 + 0.0163153871373020978498 / y10;
    const temp_q = -0.00233520497626869185443 - 0.0605183413124413191178 / y2
                   - 0.527905102951428412248 / y4 - 1.87295284992346047209 / y6
                   - 2.56852019228982242072 / y8 - 1.0 / y10;
    res = -0.6931471805599453 + Math.log(0.5641895835477563 + (temp_p / temp_q) / y2) - Math.log(-y) - y2;
  }

  if (isNaN(res)) {
    return -Infinity;
  }
  else {
    return res;
  }
}

""",
    "lnchoice": """
function lnchoice(n, k) {
    return lnfactorial(n) - lnfactorial(n-k) - lnfactorial(k);
}

""",
    "lnbeta": """
function lnbeta(x, y) {
    if (x < 0 || y < 0) {
        throw RangeError('Arguments must be positive.');
    }
    else if (x === 0 && y === 0) return NaN;
    else if (x === 0 || y === 0) return Infinity;

    return lngamma(x) + lngamma(y) - lngamma(x + y);
}

""",
    "betacf": """
function betacf(x, a, b) {
    
    
    var fpmin = 1e-30,
        m = 1,
        m2, aa, c, d, del, h, qab, qam, qap;
    
    qab = a + b;
    qap = a + 1;
    qam = a - 1;
    c = 1;
    d = 1 - qab * x / qap;
    if (Math.abs(d) < fpmin) d = fpmin;
    d = 1 / d;
    h = d;
    for (; m <= 100; m++) {
        m2 = 2 * m;
        aa = m * (b - m) * x / ((qam + m2) * (a + m2));
        
        d = 1 + aa * d;
        if (Math.abs(d) < fpmin) d = fpmin;
        c = 1 + aa / c;
        if (Math.abs(c) < fpmin) c = fpmin;
        d = 1 / d;
        h *= d * c;
        aa = -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
        
        d = 1 + aa * d;
        if (Math.abs(d) < fpmin) d = fpmin;
        c = 1 + aa / c;
        if (Math.abs(c) < fpmin) c = fpmin;
        d = 1 / d;
        del = d * c;
        h *= del;
        if (Math.abs(del - 1.0) < 3e-7) break;
    }
    return h;
}

""",
    "regularizedIncompleteBeta": """
function regularizedIncompleteBeta(x, a, b) {
    
    
    if (x < 0 || x > 1) {
        throw new RangeError('First argument must be between 0 and 1.');
    }

    
    else if (a === 1 && b === 1) return x;
    else if (x === 0) return 0;
    else if (x === 1) return 1;
    else if (a === 0) return 1;
    else if (b === 0) return 0;

    else {
        var bt = Math.exp(lngamma(a + b) - lngamma(a) - lngamma(b) + a * Math.log(x) + b * log1p(-x));

        
        if (x < (a + 1) / (a + b + 2)) return bt * betacf(x, a, b) / a;

        
        else return 1 - bt * betacf(1 - x, b, a) / b;
    }
}

""",
    "incompleteBeta": """
function incompleteBeta(x, a, b) {
    return regularizedIncompleteBeta(x, a, b) * Math.exp(lnbeta(a, b));
}

""",
    "lngamma": """
function lngamma(z) {

    if(z < 0) return Number('0/0');

    if (z < 0.5) return Math.log(Math.PI) - Math.log(Math.sin(Math.PI * z)) - lngamma(1-z);

    var p = [676.5203681218851,
             -1259.1392167224028,
             771.32342877765313,
             -176.61502916214059,
             12.507343278686905,
             -0.13857109526572012,
             9.9843695780195716e-6,
             1.5056327351493116e-7];

    z -= 1.0;
    var Ag = 0.99999999999980993;
    for (var i = 0; i < p.length; i++) {
        Ag += p[i] / (z + i + 1);
    }
    var t = z + p.length - 0.5;

    return 0.5 * Math.log(2*Math.PI) + (z + 0.5)*Math.log(t) - t + Math.log(Ag);
}

""",
    "gammaincU": """
function gammaincU(x, s, regularized) {

  var EPSILON = 1e-12;

  if (x <= 1.1 || x <= s) {
    if (regularized !== false) {
      return 1 - gammaincL(x, s, regularized);
    } else {
      return Math.exp(lngamma(s)) - gammaincL(x, s, regularized);
    }
  }

  var f = 1 + x - s,
    C = f,
    D = 0,
    i = 1,
    a, b, chg;
  for (i = 1; i < 10000; i++) {
    a = i * (s - i);
    b = (i<<1) + 1 + x - s;
    D = b + a * D;
    C = b + a / C;
    D = 1 / D;
    chg = C * D;
    f *= chg;
    if (Math.abs(chg - 1) < EPSILON) {
      break;
    }
  }
  if (regularized !== false) {
    return Math.exp(s * Math.log(x) - x - lngamma(s) - Math.log(f));
  } else {
    return Math.exp(s * Math.log(x) - x - Math.log(f));
  }
}

""",
    "gammaincL": """
function gammaincL(x, s, regularized) {

  var EPSILON = 1e-12;

  if (x === 0) {
    return 0;
  }
  if (x < 0 || s <= 0) {
    return NaN;
  }

  if (x > 1.1 && x > s) {
    if (regularized !== false) {
      return 1 - gammaincU(x, s, regularized);
    } else {
      return Math.exp(lngamma(s)) - gammaincU(x, s, regularized);
    }
  }

  var ft,
    r = s,
    c = 1,
    pws = 1;

  if (regularized !== false) {
    ft = s * Math.log(x) - x - lngamma(s);
  } else {
    ft = s * Math.log(x) - x;
  }
  ft = Math.exp(ft);
  do {
    r += 1;
    c *= x/r;
    pws += c;
  } while (c / pws > EPSILON);

  return pws * ft / s;
}

""",
    "hyp1f1": """
function hyp1f1(a, b, x) {
  let i, j, la, n, nl;
  let a0 = a, a1 = a, x0 = x, y0, y1, hg1, hg2, r1, r2, rg, xg, sum1, sum2;
  let hg = 0.0;

  
  if (x < 0.0) {
    a = b - a;
    a0 = a;
    x = Math.abs(x);
  }
  nl = 0;
  la = 0;
  if (a >= 2.0) {
    
    nl = 1;
    la = Math.floor(a);
    a -= la + 1;
  }
  y0 = 0.0;
  y1 = 0.0;
  for (n = 0; n < (nl + 1); n++) {
    if (a0 >= 2.0) { a += 1.0; }
    if ((x <= 30.0 + Math.abs(b)) || (a < 0.0)) {
      hg = 1.0;
      rg = 1.0;
      for (j = 1; j < 501; j++) {
        rg *= (a + j - 1.0) / (j * (b + j - 1.0)) * x;
        hg += rg;
        if (rg / hg < 1e-15) {
          
          if (x0 < 0.0) { hg *= Math.exp(x0); }
          break;
        }
      }
    } else {
      
      const cta = lngamma(a);
      const ctb = lngamma(b);
      xg = b - a;
      const ctba = lngamma(xg);
      sum1 = 1.0;
      sum2 = 1.0;
      r1 = 1.0;
      r2 = 1.0;
      for (i = 1; i < 9; i++) {
        r1 = -r1 * (a + i - 1.0) * (a - b + i) / (x * i);
        r2 = -r2 * (b - a + i - 1.0) * (a - i) / (x * i);
        sum1 += r1;
        sum2 += r2;
      }
      if (x0 >= 0.0) {
        hg1 = Math.exp(ctb - ctba) * Math.pow(x, -a) * Math.cos(Math.PI * a) * sum1;
        hg2 = Math.exp(ctb - cta + x) * Math.pow(x, a - b) * sum2;
      } else {
        
        hg1 = Math.exp(ctb - ctba + x0) * Math.pow(x, -a) * Math.cos(Math.PI * a) * sum1;
        hg2 = Math.exp(ctb - cta) * Math.pow(x, a - b) * sum2;
      }
      hg = hg1 + hg2;
    }
    if (n === 0) { y0 = hg; }
    if (n === 1) { y1 = hg; }
  }
  if (a0 >= 2.0) {
    
    for (i = 1; i < la; i++) {
      hg = ((2.0 * a - b + x) * y1 + (b - a) * y0) / a;
      y0 = y1;
      y1 = hg;
      a += 1.0;
    }
  }
  a = a1;
  x = x0;
  return hg;
}

""",
    "chbevl": """
function chbevl(x, A) {

  let b0, b1, b2;
  let n = A.length;
  let i = n - 1;

  b0 = A[0];
  b1 = 0.0;

  for (let j = 1; j <= i; j++) {
    b2 = b1;
    b1 = b0;
    b0 = x * b1 - b2 + A[j];
  }

  return 0.5 * (b0 - b2);
}

""",
    "polevl": """
function polevl(x, coef) {

    let result;
    let n = coef.length;

    let i = n;

    result = coef[0];

    for (let j = 1; j <= n; j++) {
        result = result * x + coef[j];
    }

    return result;
}

""",
    "besseli0": """
function besseli0(x, expWeighted = false) {

  let A = [
    -4.41534164647933937950e-18,
     3.33079451882223809783e-17,
    -2.43127984654795469359e-16,
     1.71539128555513303061e-15,
    -1.16853328779934516808e-14,
     7.67618549860493561688e-14,
    -4.85644678311192946090e-13,
     2.95505266312963983461e-12,
    -1.72682629144155570723e-11,
     9.67580903537323691224e-11,
    -5.18979560163526290666e-10,
     2.65982372468238665035e-9,
    -1.30002500998624804212e-8,
     6.04699502254191894932e-8,
    -2.67079385394061173391e-7,
     1.11738753912010371815e-6,
    -4.41673835845875056359e-6,
     1.64484480707288970893e-5,
    -5.75419501008210370398e-5,
     1.88502885095841655729e-4,
    -5.76375574538582365885e-4,
     1.63947561694133579842e-3,
    -4.32430999505057594430e-3,
     1.05464603945949983183e-2,
    -2.37374148058994688156e-2,
     4.93052842396707084878e-2,
    -9.49010970480476444210e-2,
     1.71620901522208775349e-1,
    -3.04682672343198398683e-1,
     6.76795274409476084995e-1
  ];

  let B = [
    -7.23318048787475395456e-18,
    -4.83050448594418207126e-18,
     4.46562142029675999901e-17,
     3.46122286769746109310e-17,
    -2.82762398051658348494e-16,
    -3.42548561967721913462e-16,
     1.77256013305652638360e-15,
     3.81168066935262242075e-15,
    -9.55484669882830764870e-15,
    -4.15056934728722208663e-14,
     1.54008621752140982691e-14,
     3.85277838274214270114e-13,
     7.18012445138366623367e-13,
    -1.79417853150680611778e-12,
    -1.32158118404477131188e-11,
    -3.14991652796324136454e-11,
     1.18891471078464383424e-11,
     4.94060238822496958910e-10,
     3.39623202570838634515e-9,
     2.26666899049817806459e-8,
     2.04891858946906374183e-7,
     2.89137052083475648297e-6,
     6.88975834691682398426e-5,
     3.36911647825569408990e-3,
     8.04490411014108831608e-1
  ];

  if ( x < 0 ) x = -x;

  let result;
  if (x <= 8.0) {
    let y = x / 2.0 - 2.0;
    result = chbevl(y, A);
  } else {
    result = chbevl(32.0 / x - 2.0, B) / Math.sqrt(x)
  }

  if (expWeighted) return result;
  else return Math.exp(x) * result;
}

""",
    "cosm1": """
function cosm1(x) {

  let coeffs = [
     4.7377507964246204691685E-14,
    -1.1470284843425359765671E-11,
     2.0876754287081521758361E-9,
    -2.7557319214999787979814E-7,
     2.4801587301570552304991E-5,
    -1.3888888888888872993737E-3,
     4.1666666666666666609054E-2
   ];

  let quarterPi = Math.PI / 4;

  if (x < quarterPi || x > quarterPi) return Math.cos(x) - 1.0;

  let x2 = x * x;
  return -0.5 * x2 + x2 * x2 * polevl(x2, coeffs);
}

""",
    "chebPoints": """
function chebPoints(n, low = -1, high = 1) {
  
  let points = Array.from({ length: n }, (_, i) => Math.cos(Math.PI * i / (n - 1)));

  
  let m = (high - low) / 2.0;
  let b = (high + low) / 2.0;

  points = points.map((x) => m * x + b);

  return points;
}

""",
    "clenshawCurtisWeights": """
function clenshawCurtisWeights(n) {
    n -= 1; 

    const theta = Array.from({ length: n + 1 }, (_, i) => Math.PI * i / n);
    let w = new Array(n + 1).fill(0);
    let v = new Array(n - 1).fill(1);

    if (n % 2 === 0) {
        w[0] = 1.0 / (n ** 2 - 1);
        w[n] = w[0];
        for (let k = 1; k < n / 2; k++) {
            for (let j = 1; j < n; j++) {
                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);
            }
        }
        for (let j = 1; j < n; j++) {
            v[j - 1] -= Math.cos(n * theta[j]) / (n ** 2 - 1);
        }
    } else {
        w[0] = 1.0 / n ** 2;
        w[n] = w[0];
        for (let k = 1; k <= (n - 1) / 2; k++) {
            for (let j = 1; j < n; j++) {
                v[j - 1] -= 2.0 * Math.cos(2.0 * k * theta[j]) / (4.0 * k ** 2 - 1);
            }
        }
    }

    for (let j = 1; j < n; j++) {
        w[j] = 2.0 * v[j - 1] / n;
    }

    return w;
}

""",
    "clenshawCurtisIntegrate": """
function clenshawCurtisIntegrate(f, a, b, n = 100, args = [], weights = undefined) {

  if (weights === undefined) {
    
    let ccWeights = clenshawCurtisWeights(n);

    
    weights = ccWeights.map((x) => (b - a) / 2.0 * x);
  }

  
  let x = chebPoints(n);

  
  x = x.map((x) => (b - a) / 2.0 * x + (b + a) / 2.0);

  
  let fVals = x.map((x) => f(x, ...args));

  
  return dot(weights, fVals);
}

""",
    "lnfactorial": """
function lnfactorial(n) {
  if (n > 254) { 
    let x = n + 1;
    return (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12.0 * x);
  }
  else { 
    const lnfact = [0.000000000000000,
                    0.000000000000000,
                    0.693147180559945,
                    1.791759469228055,
                    3.178053830347946,
                    4.787491742782046,
                    6.579251212010101,
                    8.525161361065415,
                    10.604602902745251,
                    12.801827480081469,
                    15.104412573075516,
                    17.502307845873887,
                    19.987214495661885,
                    22.552163853123421,
                    25.191221182738683,
                    27.899271383840894,
                    30.671860106080675,
                    33.505073450136891,
                    36.395445208033053,
                    39.339884187199495,
                    42.335616460753485,
                    45.380138898476908,
                    48.471181351835227,
                    51.606675567764377,
                    54.784729398112319,
                    58.003605222980518,
                    61.261701761002001,
                    64.557538627006323,
                    67.889743137181526,
                    71.257038967168000,
                    74.658236348830158,
                    78.092223553315307,
                    81.557959456115029,
                    85.054467017581516,
                    88.580827542197682,
                    92.136175603687079,
                    95.719694542143202,
                    99.330612454787428,
                    102.968198614513810,
                    106.631760260643450,
                    110.320639714757390,
                    114.034211781461690,
                    117.771881399745060,
                    121.533081515438640,
                    125.317271149356880,
                    129.123933639127240,
                    132.952575035616290,
                    136.802722637326350,
                    140.673923648234250,
                    144.565743946344900,
                    148.477766951773020,
                    152.409592584497350,
                    156.360836303078800,
                    160.331128216630930,
                    164.320112263195170,
                    168.327445448427650,
                    172.352797139162820,
                    176.395848406997370,
                    180.456291417543780,
                    184.533828861449510,
                    188.628173423671600,
                    192.739047287844900,
                    196.866181672889980,
                    201.009316399281570,
                    205.168199482641200,
                    209.342586752536820,
                    213.532241494563270,
                    217.736934113954250,
                    221.956441819130360,
                    226.190548323727570,
                    230.439043565776930,
                    234.701723442818260,
                    238.978389561834350,
                    243.268849002982730,
                    247.572914096186910,
                    251.890402209723190,
                    256.221135550009480,
                    260.564940971863220,
                    264.921649798552780,
                    269.291097651019810,
                    273.673124285693690,
                    278.067573440366120,
                    282.474292687630400,
                    286.893133295426990,
                    291.323950094270290,
                    295.766601350760600,
                    300.220948647014100,
                    304.686856765668720,
                    309.164193580146900,
                    313.652829949878990,
                    318.152639620209300,
                    322.663499126726210,
                    327.185287703775200,
                    331.717887196928470,
                    336.261181979198450,
                    340.815058870798960,
                    345.379407062266860,
                    349.954118040770250,
                    354.539085519440790,
                    359.134205369575340,
                    363.739375555563470,
                    368.354496072404690,
                    372.979468885689020,
                    377.614197873918670,
                    382.258588773060010,
                    386.912549123217560,
                    391.575988217329610,
                    396.248817051791490,
                    400.930948278915760,
                    405.622296161144900,
                    410.322776526937280,
                    415.032306728249580,
                    419.750805599544780,
                    424.478193418257090,
                    429.214391866651570,
                    433.959323995014870,
                    438.712914186121170,
                    443.475088120918940,
                    448.245772745384610,
                    453.024896238496130,
                    457.812387981278110,
                    462.608178526874890,
                    467.412199571608080,
                    472.224383926980520,
                    477.044665492585580,
                    481.872979229887900,
                    486.709261136839360,
                    491.553448223298010,
                    496.405478487217580,
                    501.265290891579240,
                    506.132825342034830,
                    511.008022665236070,
                    515.890824587822520,
                    520.781173716044240,
                    525.679013515995050,
                    530.584288294433580,
                    535.496943180169520,
                    540.416924105997740,
                    545.344177791154950,
                    550.278651724285620,
                    555.220294146894960,
                    560.169054037273100,
                    565.124881094874350,
                    570.087725725134190,
                    575.057539024710200,
                    580.034272767130800,
                    585.017879388839220,
                    590.008311975617860,
                    595.005524249382010,
                    600.009470555327430,
                    605.020105849423770,
                    610.037385686238740,
                    615.061266207084940,
                    620.091704128477430,
                    625.128656730891070,
                    630.172081847810200,
                    635.221937855059760,
                    640.278183660408100,
                    645.340778693435030,
                    650.409682895655240,
                    655.484856710889060,
                    660.566261075873510,
                    665.653857411105950,
                    670.747607611912710,
                    675.847474039736880,
                    680.953419513637530,
                    686.065407301994010,
                    691.183401114410800,
                    696.307365093814040,
                    701.437263808737160,
                    706.573062245787470,
                    711.714725802289990,
                    716.862220279103440,
                    722.015511873601330,
                    727.174567172815840,
                    732.339353146739310,
                    737.509837141777440,
                    742.685986874351220,
                    747.867770424643370,
                    753.055156230484160,
                    758.248113081374300,
                    763.446610112640200,
                    768.650616799717000,
                    773.860102952558460,
                    779.075038710167410,
                    784.295394535245690,
                    789.521141208958970,
                    794.752249825813460,
                    799.988691788643450,
                    805.230438803703120,
                    810.477462875863580,
                    815.729736303910160,
                    820.987231675937890,
                    826.249921864842800,
                    831.517780023906310,
                    836.790779582469900,
                    842.068894241700490,
                    847.352097970438420,
                    852.640365001133090,
                    857.933669825857460,
                    863.231987192405430,
                    868.535292100464630,
                    873.843559797865740,
                    879.156765776907600,
                    884.474885770751830,
                    889.797895749890240,
                    895.125771918679900,
                    900.458490711945270,
                    905.796028791646340,
                    911.138363043611210,
                    916.485470574328820,
                    921.837328707804890,
                    927.193914982476710,
                    932.555207148186240,
                    937.921183163208070,
                    943.291821191335660,
                    948.667099599019820,
                    954.046996952560450,
                    959.431492015349480,
                    964.820563745165940,
                    970.214191291518320,
                    975.612353993036210,
                    981.015031374908400,
                    986.422203146368590,
                    991.833849198223450,
                    997.249949600427840,
                    1002.670484599700300,
                    1008.095434617181700,
                    1013.524780246136200,
                    1018.958502249690200,
                    1024.396581558613400,
                    1029.838999269135500,
                    1035.285736640801600,
                    1040.736775094367400,
                    1046.192096209724900,
                    1051.651681723869200,
                    1057.115513528895000,
                    1062.583573670030100,
                    1068.055844343701400,
                    1073.532307895632800,
                    1079.012946818975000,
                    1084.497743752465600,
                    1089.986681478622400,
                    1095.479742921962700,
                    1100.976911147256000,
                    1106.478169357800900,
                    1111.983500893733000,
                    1117.492889230361000,
                    1123.006317976526100,
                    1128.523770872990800,
                    1134.045231790853000,
                    1139.570684729984800,
                    1145.100113817496100,
                    1150.633503306223700,
                    1156.170837573242400];
    return lnfact[n];
  }
}

""",
    "transpose": """
function transpose(A) {
    return A[0].map((_, colIndex) => A.map(row => row[colIndex]));
}

""",
    "mvMult": """
function mvMult(A, v) {
  return A.map(Arow => dot(Arow, v));
}

""",
    "svMult": """
function svMult(a, v) {
  return v.map(x => a * x);
}

""",
    "smMult": """
function smMult(a, A) {
  return A.map(Arow => svMult(a, Arow));
}

""",
    "svAdd": """
function svAdd(a, v) {
  return v.map(x => a + x);
}

""",
    "mmMult": """
function mmMult(A, B) {
  let mA = A.length;
  let nA = A[0].length;
  let mB = B.length;
  let nB = B[0].length;

  if (nA !== mB) {
      throw new Error('Matrix dimension mismatch.');
  }

  let result = zeros(mA, nB);

  for (let i = 0; i < mA; i++) {
    for (let j = 0; j < nB; j++) {
      for (let k = 0; k < nA; k++) {
        result[i][j] += A[i][k] * B[k][j];
      }
    }
  }

  return result;
}

""",
    "vectorAdd": """
function vectorAdd() {
  let m = arguments.length;
  let n = arguments[0].length;
 
  let result = new Array(n).fill(0.0);
 
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
        result[i] += arguments[j][i];
    }
  }

  return result;
}

""",
    "elementwiseVectorDivide": """
function elementwiseVectorDivide(v1, v2) {
  return v1.map((value, i) => value / v2[i]);
}

""",
    "elementwiseVectorMult": """
function elementwiseVectorMult(v1, v2) {
  return v1.map((value, i) => value * v2[i]);
}

""",
    "svMultAdd": """
function svMultAdd(scalars, vectors) {
  let m = scalars.length;
  let n = vectors[0].length;

  if (vectors.length != m) {
      console.warn("svMultAdd: Different number of scalars and vectors.");
      return null;
  }

  let result = new Array(n).fill(0.0);
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < m; j++) {
      result[i] += scalars[j] * vectors[j][i];
    }
  }

  return result;
}

""",
    "absVector": """
function absVector(v) {
  return v.map(x => Math.abs(x));
}

""",
    "dot": """
function dot(v1, v2) {
  const n = v1.length;
  let result = 0.0;
  for (let i = 0; i < n; i++) result += v1[i] * v2[i];

  return result;
}

""",
    "norm": """
function norm(v) {
  return Math.sqrt(dot(v, v));
}

""",
    "quadForm": """
function quadForm(A, x) {
   return dot(x, mvMult(A, x)); 
}

""",
    "shallowCopyMatrix": """
function shallowCopyMatrix(A) {
  var Ac = [];
  var n = A.length;
  for (i = 0; i < n; i++) {
      Ac.push([...A[i]]);
  }

  return Ac;
}

""",
    "deepCopy": """
function deepCopy(x) {
  return JSON.parse(JSON.stringify(x));
}

""",
    "zeros": """
function zeros(...dims) {
  let A = [];

  
  for (let i = dims.length - 1; i >= 0; i--) {
    let size = dims[i];
    if (i === dims.length - 1) {
      
      A = new Array(size).fill(0.0);
    } else {
      
      A = new Array(size).fill().map(() => deepCopy(A));
    }
  }

  return A;
}

""",
    "lowerTriSolve": """
function lowerTriSolve(L, b) {
    const floatEps = 1.0e-14;
    const n = L.length;

    
    let x = Array.from(b);

    
    for (let j = 0; j < n - 1; j++) {
        if (Math.abs(L[j][j]) > floatEps) {
            x[j] /= L[j][j];
            for (let i = j + 1; i < n; i++) {
                x[i] -= x[j] * L[i][j];
            }
        } else {
            x[j] = 0.0;
        }
    }

    if (n > 0) {
        if (Math.abs(L[n - 1][n - 1]) > floatEps) {
            x[n - 1] /= L[n - 1][n - 1];
        } else {
            x[n - 1] = 0.0;
        }
    }

    return x;
}

""",
    "upperTriSolve": """
function upperTriSolve(U, b) {
    const floatEps = 1.0e-14;
    const n = U.length;

    
    let x = Array.from(b);

    
    for (let j = n - 1; j > 0; j--) {
        if (Math.abs(U[j][j]) > floatEps) {
            x[j] /= U[j][j];
            for (let i = 0; i < j; i++) {
                x[i] -= x[j] * U[i][j];
            }
        } else {
            x[j] = 0.0;
        }
    }

    if (n > 0) {
        if (Math.abs(U[0][0]) > floatEps) {
            x[0] /= U[0][0];
        } else {
            x[0] = 0.0;
        }
    }

    return x;
}

""",
    "modifiedCholesky": """
function modifiedCholesky(A) {
    const floatEps = 1.0e-14;
    const n = A.length;

    
    let L = deepCopy(A); 
    let p = arange(0, n);

    
    let success = true;

    let xi = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < i; j++) {
            let temp = Math.abs(L[i][j]);
            xi = Math.max(xi, temp);
        }
    }

    let eta = 0;
    for (let i = 0; i < n; i++) {
        let temp = Math.abs(L[i][i]);
        eta = Math.max(eta, temp);
    }

    let beta;
    if (n > 1) {
        beta = Math.sqrt(Math.max(eta, xi / Math.sqrt(n * n - 1)));
    } else {
        beta = Math.sqrt(eta);
    }
    beta = Math.max(beta, floatEps);

    for (let k = 0; k < n; k++) {
        
        let muVal = L[k][k];
        let mu = k;
        for (let i = k + 1; i < n; i++) {
            let temp = L[i][i];
            if (muVal < temp) {
                mu = i;
                muVal = temp;
            }
        }

        
        let iTemp = p[mu];
        p[mu] = p[k];
        p[k] = iTemp;

        for (let i = 0; i < k; i++) {
            let temp = L[k][i];
            L[k][i] = L[mu][i];
            L[mu][i] = temp;
        }

        let temp = L[k][k];
        L[k][k] = L[mu][mu];
        L[mu][mu] = temp;
        for (let i = k + 1; i < mu; i++) {
            let temp = L[i][k];
            L[i][k] = L[mu][i];
            L[mu][i] = temp;
        }

        for (let i = mu + 1; i < n; i++) {
            let temp = L[i][k];
            L[i][k] = L[i][mu];
            L[i][mu] = temp;
        }

        
        let cSum = 0;
        for (let i = k + 1; i < n; i++) {
            cSum = Math.max(cSum, Math.abs(L[i][k]));
        }
        cSum /= beta;
        cSum = cSum * cSum;

        
        if (L[k][k] < 0) {
            success = false;
        }

        temp = Math.abs(L[k][k]);
        temp = Math.max(temp, floatEps * eta);
        temp = Math.max(temp, cSum);
        L[k][k] = Math.sqrt(temp);

        
        for (let i = k + 1; i < n; i++) {
            L[i][k] /= L[k][k];
        }

        
        for (let j = k + 1; j < n; j++) {
            for (let i = j; i < n; i++) {
                L[i][j] -= L[i][k] * L[j][k];
            }
        }

        
        for (let i = 0; i < n - 1; i++) {
            for (let j = i + 1; j < n; j++) {
                L[i][j] = 0.0;
            }
        }
    }

    return [L, p, success];
}

""",
    "modifiedCholeskySolve": """
function modifiedCholeskySolve(L, p, b) {
    const n = L.length;

    let U = transpose(L);
    let xp = new Array(n).fill(0);
    for (let i = 0; i < n; i++) {
        xp[i] = b[p[i]];
    }

    
    let x = lowerTriSolve(L, xp);

    
    xp = upperTriSolve(U, x);

    for (let i = 0; i < n; i++) {
        x[p[i]] = xp[i];
    }

    return x;
}

""",
    "solvePosDef": """
function solvePosDef(A, b) {
  let [L, p, success] = modifiedCholesky(A);

  if (!success) {
    return [zeros(b.length), success];
  }

  return [modifiedCholeskySolve(L, p, b), success];
}

""",
    "LUPDecompose": """
function LUPDecompose(A, eps) {
    var i, j, k, imax;
    var maxA, absA;
    var Arow;
    var p = [];
    var n = A.length;
    var LU = shallowCopyMatrix(A);

    
    for (i = 0; i <= n; i++) p.push(i);

    for (i = 0; i < n; i++) {
        maxA = 0.0;
        imax = i;

        for (k = i; k < n; k++) {
            absA = Math.abs(LU[k][i]);
            if (absA > maxA) {
                maxA = absA;
                imax = k;
            }
        }

        
        if (maxA < eps) return [null, null];

        if (imax != i) {
            
            j = p[i];
            p[i] = p[imax];
            p[imax] = j;

            
            Arow = LU[i];
            LU[i] = LU[imax];
            LU[imax] = Arow;

            
            p[n]++;
        }

        for (j = i + 1; j < n; j++) {
            LU[j][i] /= LU[i][i];

            for (k = i + 1; k < n; k++) LU[j][k] -= LU[j][i] * LU[i][k];
        }
    }

    return [LU, p];
}

""",
    "LUPSolve": """
function LUPSolve(LU, p, b) {
    var n = b.length;
    var x = [];

    for (var i = 0; i < n; i++) {
        x.push(b[p[i]]);
        for (var k = 0; k < i; k++) x[i] -= LU[i][k] * x[k];
    }

    for (i = n - 1; i >= 0; i--) {
        for (k = i + 1; k < n; k++) x[i] -= LU[i][k] * x[k];

        x[i] /= LU[i][i];
    }

    return x;
}

""",
    "solve": """
function solvePosDef(A, b) {
  let [L, p, success] = modifiedCholesky(A);

  if (!success) {
    return [zeros(b.length), success];
  }

  return [modifiedCholeskySolve(L, p, b), success];
}

""",
    "paramsFromSliders": """
function paramsFromSliders(sliders) {
  let params = [];
  for (let slider of sliders) {
    params.push(slider.value);
  }

  return params;
}

""",
    "paramsFromBoxes": """
function paramsFromBoxes(boxes) {
  let params = [];
  for (let box of boxes) {
    if (isNaN(box.value)) {
      throw new Error(box.value + ' is not a valid number.');
    }
    params.push(Number(box.value));
  }

  return params;
}

""",
    "setYRanges": """
function setYRanges(p_p, p_c, source_p) {
    p_c.y_range.start = 0.0;
    p_c.y_range.end = 1.0;        

    let pdfMax = source_p.data['y_p'];
    p_p.y_range.start = 0.0;
    p_p.y_range.end = 1.04 * pdfMax;

}

""",
    "checkQuantileInput": """
function checkQuantileInput(x, p, xMin, xMax, varName, quantileSetterDiv) {
  for (let i = 0; i < x.length; i++) {
    if (p[i] <= 0 || p[i] >= 1) {
      quantileSetterDiv.text = '<p style="color:tomato;">Must have 0 < quantile < 1.</p>';
      return false; 
    }

    if (x[i] < xMin || x[i] > xMax) {
      let qStr = '<p style="color:tomato;">Must have ' + xMin.toString() + ' ≤ yy ≤ ' + xMax.toString() + '.</p>';
      quantileSetterDiv.text = qStr.replace(/yy/g, varName);
      return false;
    }
  }


  if (p.length === 2) {
    if (p[1] <= 0 || p[1] >= 1) {
        quantileSetterDiv.text = '<p style="color:tomato;">Must have 0 < quantile < 1.</p>';
        return false;
    }

    if (p[0] >= p[1]) {
        quantileSetterDiv.text = '<p style="color:tomato;">Lower quantile must be less than upper quantile.</p>';
        return false;
    }

    if (x[0] >= x[1]) {
        quantileSetterDiv.text = '<p style="color:tomato;">Lower yy must be less than upper yy.</p>'.replace(/yy/g, varName);
        return false;        
    }
  }

  if (p.length === 3) {
    if (p[2] <= 0 || p[2] >= 1 || p[1] <= 0 || p[1] >= 1) {
        quantileSetterDiv.text = '<p style="color:tomato;">Must have 0 < quantile < 1.</p>';
        return false;
    }

    if (p[0] >= p[1] || p[1] >= p[2]) {
        quantileSetterDiv.text = '<p style="color:tomato;">Quantiles must be ordered lower, middle, upper.</p>';
        return false;
    }

    if (x[0] >= x[1] || x[1] >= x[2]) {
        quantileSetterDiv.text = '<p style="color:tomato;">yy values must be ordered, lower, middle, upper.</p>'.replace(/yy/g, varName);
        return false;
    }
  }

    return true;
}

""",
    "updateContinuousPDFandCDF": """
function updateContinuousPDFandCDF(source_p, source_c, xRange, sliders) {
  
  let x_p = source_p.data['x'];
  let y_p = source_p.data['y_p'];
  let x_c = source_c.data['x'];
  let y_c = source_c.data['y_c'];
  let xRangeMin = xRange.start;
  let xRangeMax = xRange.end;

  
  x_p = linspace(xRangeMin, xRangeMax, n);
  x_c = x_p;

  
  source_p.data['x'] = x_p;
  source_c.data['x'] = x_c;

  
  let params = paramsFromSliders(sliders);

  
  let pdf = dist.pdf(x_p, params);

  
  pdf = pdf.map(val => (val === Infinity || val === -Infinity) ? NaN : val);

  
  source_p.data['y_p'] = pdf;
  source_c.data['y_c'] = dist.cdf(x_c, params);

  source_p.change.emit();
  source_c.change.emit();
}

""",
    "updateDiscretePMFandCDF": """
function updateDiscretePMFandCDF(source_p, source_c, xRange, sliders) {
  
  let xRangeMin = Math.ceil(xRange.start);
  let xRangeMax = Math.floor(xRange.end);

  
  let x_p = arange(xRangeMin, xRangeMax + 1);

  
  let x_c;
  if (Number.isInteger(xRange.start)) {
    if (Number.isInteger(xRange.end)) {
      x_c = x_p.flatMap(x => [x, x]);
    }
    else {
      x_c = [...x_p.flatMap(x => [x, x]), xRange.end];
    }
  }
  else {
    if (Number.isInteger(xRange.end)) {
      x_c = [xRange.start, ...x_p.flatMap(x => [x, x])];
    }
    else {
      x_c = [xRange.start, ...x_p.flatMap(x => [x, x]), xRange.end];
    }    
  }

  
  source_p.data['x'] = x_p;
  source_c.data['x'] = x_c;

  
  let params = paramsFromSliders(sliders);

  
  source_p.data['y_p'] = dist.pmf(x_p, params);
  source_c.data['y_c'] = dist.cdfForPlotting(x_c[0], x_c[x_c.length - 1], params);

  source_p.change.emit();
  source_c.change.emit();
}

""",
    "updateData": """
function updateData(source_p, source_c, p_p, sliders, discrete) {
  if (discrete) {
    updateDiscretePMFandCDF(source_p, source_c, p_p.x_range, sliders);
  }
  else {
    updateContinuousPDFandCDF(source_p, source_c, p_p.x_range, sliders);
  }
}

""",
    "updateQuantiles": """
function updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes) {
  if (!quantileSetterSwitch.active) {
    let params = paramsFromSliders(sliders);

    for (let i = 0; i < xBoxes.length; i++) {
      xBoxes[i].value = dist.ppfSingleValue(Number(pBoxes[i].value), params).toPrecision(4);
    }
  }
}

""",
    "quantileSetter": """
function quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p) {
  
  triggerCallbacks.active = false;

  
  let inputOk;
  try {
    var x = paramsFromBoxes(xBoxes);
    var p = paramsFromBoxes(pBoxes);

    
    var params = paramsFromSliders(sliders);

    
    inputOk = checkQuantileInput(x, p, dist.hardMin, dist.hardMax, dist.varName, quantileSetterDiv);
  } catch (e) {
    quantileSetterDiv.text = '<p style="color:tomato;">' + e.message; + '</p>';
    inputOk = false;
  }

  if (inputOk) {
    
    let extraParams = [];
    for (let i = 0; i < dist.paramNames.length; i++) {
      if (dist.fixedParamsInds.includes(i)) {
        extraParams.push(params[i]);
      }
    }

    
    let errText = '<p style="color:tomato;">Failed to find parameters to match quantiles.</p>';

    
    let optimParams, optimSuccess;
    try {
      [optimParams, optimSuccess] = dist.quantileSet(x, p, extraParams);
    } catch(e) {
      optimSuccess = false;
      errText = '<p style="color:tomato;">' + e.message; + '</p>';
    }

    let text;
    if (optimSuccess) {
      
      text = '<p>';
      for (let i = 0; i < optimParams.length - 1; i++) {
        text += dist.paramNames[dist.activeParamsInds[i]] + ' = ' + optimParams[i].toPrecision(4) + ', ';
      }
      let i = optimParams.length - 1;
      text += dist.paramNames[dist.activeParamsInds[i]] + ' = ' + optimParams[i].toPrecision(4) + '</p>';
    } else{
      text = errText;
    }

    quantileSetterDiv.text = text;

    if (optimSuccess) {
      
      let params = [];
      let aInd = 0;
      for (let i = 0; i < sliders.length; i++) {
        if (dist.activeParamsInds.includes(i)) {
          params.push(optimParams[aInd]);

          
          sliders[i].value = optimParams[aInd];

          aInd += 1;
        } else { 
          params.push(sliders[i].value);
        }
      }

      
      for (let i = 0; i < optimParams.length; i++ ) {
        if (sliders[dist.activeParamsInds[i]].start > optimParams[i] || sliders[dist.activeParamsInds[i]].end < optimParams[i]) {
          
          if (dist.locationParamInd === dist.activeParamsInds[i] || dist.paramMin[dist.activeParamsInds[i]] < 0) {
            let width = (dist.ppf(0.975, params) - dist.ppf(0.025, params)) / 2;
            startBoxes[dist.activeParamsInds[i]].value = (optimParams[i] - width).toPrecision(4);
            endBoxes[dist.activeParamsInds[i]].value = (optimParams[i] + width).toPrecision(4);
          } else {
            startBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i] / 1001).toPrecision(4);
            endBoxes[dist.activeParamsInds[i]].value = (4 * optimParams[i]).toPrecision(4);
          }
        }
        
        sliders[dist.activeParamsInds[i]].start = Number(startBoxes[dist.activeParamsInds[i]].value);
        sliders[dist.activeParamsInds[i]].end = Number(endBoxes[dist.activeParamsInds[i]].value);
      }

      
      let [x1, x2] = dist.defaultXRange(params);

      p_p.x_range.start = x1;
      p_p.x_range.end = x2;

      
      updateData(source_p, source_c, p_p, sliders, discrete);

      
      setYRanges(p_p, p_c, source_p);  
    }
  }

  
  triggerCallbacks.active = true;  
}

""",
    "jacCentralDiff": """
function jacCentralDiff(f, x, args=[], eps=4.7e-6) {
	
	let xPlus = deepCopy(x);
	let xMinus = deepCopy(x);

	
	let fOfx = f(x, ...args);
	let m = fOfx.length;

	
	let n = x.length;

	
	let J = zeros(m, n);

	
	let fOfxPlus;
	let fOfxMinus;

	for (let j = 0; j < n; j++) {
		xPlus[j] += eps;
		xMinus[j] -= eps;
		fOfxPlus = f(xPlus, ...args);
		fOfxMinus = f(xMinus, ...args);
		xPlus[j] -= eps;
		xMinus[j] += eps;

		for (let i = 0; i < m; i++) {
			J[i][j] = (fOfxPlus[i] - fOfxMinus[i]) / 2.0 / eps;
		}
	}

	return J;
}

""",
    "findRootTrustRegion": """
function findRootTrustRegion(
		f, 
		x0, 
		args=[],
		jac=jacCentralDiff,
		tol=0.000000001, 
		maxIters=10000, 
		deltaBar=1000.0, 
		eta=0.125, 
		minDelta=1e-12
  ) {
	
	let x = deepCopy(x0);

	
	let delta = 0.99 * deltaBar;

	
	let r = f(x, ...args);

	
	let J = jac(f, x, args);

	
	let JTJ = mmMult(transpose(J), J);

	
	let JTr = mvMult(transpose(J), r);

	
	let normJTr = norm(JTr);

	let iters = 0;
	while (iters < maxIters && checkTol(r, tol) && delta >= minDelta) {
		
		let p = doglegStep(JTJ, JTr, normJTr, delta);

		
		let newr = f(vectorAdd(x, p), ...args);
		let rho = computeRho(r, newr, J, p);

		
		if  (rho < 0.25) {
			delta = norm(p) / 4.0;
		} else if (rho > 0.75 && Math.abs(norm(p) - delta) < 1e-12) {
				delta = Math.min(2 * delta, deltaBar);
		}

		
		if (rho > eta) {
			x = vectorAdd(x, p);

			r = newr;
			J = jac(f, x, args);
			JTJ = mmMult(transpose(J), J);
			JTr = mvMult(transpose(J), r);
			normJTr = norm(JTr);
		}

		iters += 1;
	}

	let success = !checkTol(r, tol);

	return [x, success];

}

""",
    "computeRho": """
function computeRho(r, newr, J, p) {
	let r2 = norm(r) ** 2;
	let num = r2 - norm(newr)**2;
	let denom = r2 - norm(vectorAdd(r, mvMult(J, p))) ** 2;

	return num / denom;
}

""",
    "checkTol": """
function checkTol(r, tol) {
	
	const n = r.length;
	for (let i = 0; i < n; i++) {
		if (tol < Math.abs(r[i])) return true;
	}

	return false;
}

""",
    "doglegStep": """
function doglegStep(JTJ, JTr, normJTr, delta) {
	
	let [pJ, posDef] = solvePosDef(JTJ, JTr);
	pJ = svMult(-1.0, pJ);

	
	if (posDef && norm(pJ) <= delta) {
		return pJ;
	}

	
	let tau = Math.min(1, normJTr**3 / delta / quadForm(JTJ, JTr));
	let pC = svMult(-tau * delta / normJTr, JTr);

	let pCnorm = norm(pC);
	if (!posDef || Math.abs(pCnorm - delta) <= 1e-12) {
		return pC;
	}

	
	let pJ2 = norm(pJ) ** 2;
	let pC2 = pCnorm**2;
	let pJpC = dot(pJ, pC);
	let a = pJ2 + pC2 - 2.0 * pJpC;
	let b = 2.0 * (pJpC - pC2);
	let c = pC2 - delta**2;
	let q = -0.5 * (b + Math.sign(b) * Math.sqrt(b**2 - 4.0 * a * c));

	
	let beta;
	if (Math.abs(b) < 1e-12) beta = Math.sqrt(-c / a);
	else if (b < 0.0) beta = q / a;
	else beta = c / q;

	
	if (0.0 <= beta && beta <= 1) {
		return vectorAdd(pC, svMult(beta, vectorAdd(pJ, svMult(-1.0, pC))));
	} else { 
		return pC;
	}

}

""",
    "bisectionSolve": """
function bisectionSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {
	
  if (f(lower, ...args) * f(upper, ...args) >= 0) return null;

  let mid = lower;
  for (let i = 0; i < maxIter; i++) {
    mid = (lower + upper) / 2;
    let fMid = f(mid, ...args);

    if (fMid === 0 || (upper - lower) / 2 < tol) return mid;

    if (fMid * f(lower, ...args) > 0) lower = mid;
    else upper = mid;
  }

  return mid;
}

""",
    "newtonSolve": """
function newtonSolve(x0, f, df, args=[], tol=1e-8, maxIter=200, epsilon=1e-14) {
	let x = Infinity;
	let solved = false;

  for (let i = 0; i < maxIter; i++) {
      let y = f(x0, ...args);
      let yprime = df(x0, ...args);

      if (Math.abs(yprime) < epsilon) {
      	break;
			}

      x = x0 - y / yprime;

      if (Math.abs(x - x0) <= tol) {
      	solved = true;
      	break;
      }

      x0 = x;
  }

  if (solved) return x;
  else return null;
}

""",
    "secantSolve": """
function secantSolve(x0, f, args=[], tol=1e-8, maxIter=200, epsilon=1e-14, h=1e-4) {
	let x = Infinity;
	let solved = false;

	let x1 = x0 * (1 + h);
	x1 += x1 >= 0 ? h : -h;

	let q0 = f(x0, ...args);
	let q1 = f(x1, ...args);
	
	if (Math.abs(q1) < Math.abs(q0)) {
		[x0, x1, q0, q1] = [x1, x0, q1, q0];
	}

	for (let i = 0; i < maxIter; i++) {
		if (q0 == q1) {
			solved = x0 == x1;
			x = (x0 + x1) / 2.0;
			break;
		}
		else {
			if (Math.abs(q1) > Math.abs(q0)) {
				x = (x0 - q0 / q1 * x1) / (1.0 - q0 / q1);
			}
			else {
				x = (x1 - q1 / q0 * x0) / (1.0 - q1 / q0);
			}
			if (Math.abs(x - x0) <= tol) {
				solved = true;
				break;
			}
			[x0, q0] = [x1, q1];
			x1 = x;
			q1 = f(x1, ...args);
		}
	}

  if (solved) return x;
  else return null;
}

""",
    "brentSolve": """
function brentSolve(f, lower, upper, args=[], tol=1e-8, maxIter=1000) {
	let a = lower;
	let b = upper;
  let fa = f(a, ...args);
  let fb = f(b, ...args);

  
  if (Math.abs(fa) < tol) return a;
  if (Math.abs(fb) < tol) return b;

  
  if (fa * fb >= 0) {
  	return null;
	}

  
  let c = a;
  let fc = fa;

	let iter = 0;
  while (iter++ < maxIter) {
  	let prevStep = b - a;

    
    if (Math.abs(fc) < Math.abs(fb)) {      
    	[a, b, c] = [b, c, b];
    	[fa, fb, fc] = [fb, fc, fb];
    }

    
    let newStep = (c - b) / 2.0;

    
    let tolAdj = 1e-15 * Math.abs(b) + tol / 2;

    
  	if (Math.abs(newStep) <= tolAdj || fb === 0 ) {
    		return b;
  	}

    
    if (Math.abs(prevStep) > tolAdj && Math.abs(fa) > Math.abs(fb)) {
    	let p;
    	let q;
    	let t1;
    	let t2;
    	let cb = c - b;
    	if (a === c) { 
    		t1 = fb / fa;
    		p = cb * t1;
    		q = 1.0 - t1;
    	}
    	else { 
    		q = fa / fc;
    		t1 = fb / fc;
    		t2 = fb / fa;
    		p = t2 * (cb * q * (q - t1) - (b - a) * (t1 - 1.0));
    		q = (q - 1.0) * (t1 - 1.0) * (t2 - 1.0);
    	}

    	
    	if (p > 0) q = -q;
    	else p = -p;

    	
    	if (p < (0.75 * cb * q - Math.abs(tolAdj * q) / 2.0) 
    		&& p < Math.abs(prevStep * q / 2.0)) { 
	        newStep = p / q;
      	}
    }

    if (Math.abs(newStep) < tolAdj) {
      newStep = (newStep > 0) ? tolAdj : -tolAdj;
    }

    
    a = b;
    fa = fb;

    
    b += newStep;
    fb = f(b, ...args);

	
    if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {
      c = a; 
      fc = fa;
    }
  }

  
  return null;
}

""",
    "slider_start_callback": """

slider.start = Math.max(minValue, Number(cb_obj.value));
slider.step = (slider.end - slider.start) / 1000;""",
    "slider_end_callback": """

slider.end = Math.min(maxValue, Number(cb_obj.value));
slider.step = (slider.end - slider.start) / 1000;""",
    "int_slider_start_callback": """


slider.start = Math.max(Math.floor(minValue), Math.floor(Number(cb_obj.value)));""",
    "int_slider_end_callback": """


slider.end = Math.min(Math.floor(maxValue), Math.floor(Number(cb_obj.value)));""",
    "quantile_setter_switch_callback": """

if (cb_obj.active) {
  for (let i = 0; i < sliders.length; i++) {
    if (!dist.fixedParamsInds.includes(i)) {
      sliders[i].title = dist.paramNames[i] + ' (computed)';
      sliders[i].disabled = true;
    }
  }
  for (let xBox of xBoxes) {
    xBox.disabled = false;
  }
  for (let pBox of pBoxes) {
    pBox.disabled = false;
  }
} else {
  for (let i = 0; i < sliders.length; i++) {
    if (!dist.fixedParamsInds.includes(i)) {
      sliders[i].title = dist.paramNames[i];
      sliders[i].disabled = false;
    }
  }
  for (let xBox of xBoxes) {
    xBox.disabled = true;
  }
  for (let pBox of pBoxes) {
    pBox.disabled = true;
  }
  quantileSetterDiv.text = '';
}""",
    "quantile_setter_callback": """

if (quantileSetterSwitch.active) {
  quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);
}""",
    "reset_button_callback": """

let params = paramsFromSliders(sliders); 


let [x1, x2] = dist.defaultXRange(params);


triggerCallbacks.active = false;


p_p.x_range.start = x1;
p_p.x_range.end = x2;

updateData(source_p, source_c, p_p, sliders, discrete);


setYRanges(p_p, p_c, source_p);  

triggerCallbacks.active = true;
""",
    "slider_callback": """

if (triggerCallbacks.active && !cb_obj.disabled) {
	if (quantileSetterSwitch.active) {
		quantileSetter(xBoxes, pBoxes, quantileSetterDiv, sliders, startBoxes, endBoxes, p_p, p_c, source_p);
	}
	else {
		updateData(source_p, source_c, p_p, sliders, discrete);
		updateQuantiles(quantileSetterSwitch, sliders, xBoxes, pBoxes);
	}
}""",
    "xaxis_change_callback": """
if (triggerCallbacks.active) {
  updateData(source_p, source_c, p_p, sliders, discrete);
}""",
}

_dependencies = {
    "UnivariateDistribution": [],
    "DiscreteUnivariateDistribution": ['UnivariateDistribution', 'isclose'],
    "ContinuousUnivariateDistribution": ['UnivariateDistribution'],
    "TemplateDiscreteUnivariateDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'isclose'],
    "TemplateContinuousUnivariateDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "BernoulliDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'isclose'],
    "BetaBinomialDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'lnchoice', 'lnbeta', 'lnfactorial', 'lngamma', 'isclose'],
    "BinomialDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'lnchoice', 'regularizedIncompleteBeta', 'brentSolve', 'lnfactorial', 'log1p', 'betacf', 'lngamma', 'isclose'],
    "CategoricalDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'isclose'],
    "DiscreteUniformDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'isclose'],
    "GeometricDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'isclose'],
    "HypergeometricDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'lnchoice', 'lnfactorial', 'isclose'],
    "NegativeBinomialDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'BinomialDistribution', 'PoissonDistribution', 'regularizedIncompleteBeta', 'lngamma', 'lnfactorial', 'findRootTrustRegion', 'bisectionSolve', 'brentSolve', 'lnchoice', 'log1p', 'betacf', 'isclose', 'gammaincU', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'gammaincL', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "NegativeBinomialMuPhiDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'NegativeBinomialDistribution', 'BinomialDistribution', 'PoissonDistribution', 'regularizedIncompleteBeta', 'lngamma', 'lnfactorial', 'findRootTrustRegion', 'bisectionSolve', 'brentSolve', 'lnchoice', 'log1p', 'betacf', 'isclose', 'gammaincU', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'gammaincL', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "NegativeBinomialAlphaPDistribution": [],
    "NegativeBinomialRBDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'NegativeBinomialDistribution', 'BinomialDistribution', 'PoissonDistribution', 'regularizedIncompleteBeta', 'lngamma', 'lnfactorial', 'findRootTrustRegion', 'bisectionSolve', 'brentSolve', 'lnchoice', 'log1p', 'betacf', 'isclose', 'gammaincU', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'gammaincL', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "PoissonDistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'gammaincU', 'lnfactorial', 'brentSolve', 'lngamma', 'gammaincL', 'isclose'],
    "TelegraphRNADistribution": ['UnivariateDistribution', 'DiscreteUnivariateDistribution', 'lngamma', 'hyp1f1', 'lnfactorial', 'brentSolve', 'isclose'],
    "BetaDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'isone', 'iszero', 'lnbeta', 'regularizedIncompleteBeta', 'findRootTrustRegion', 'brentSolve', 'isclose', 'lngamma', 'log1p', 'betacf', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "BetaPhiKappaDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'BetaDistribution', 'isone', 'iszero', 'lnbeta', 'regularizedIncompleteBeta', 'findRootTrustRegion', 'brentSolve', 'isclose', 'lngamma', 'log1p', 'betacf', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "CauchyDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "ExponentialDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "GammaDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'lngamma', 'gammaincL', 'norm', 'findRootTrustRegion', 'secantSolve', 'brentSolve', 'gammaincU', 'dot', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "HalfCauchyDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "HalfNormalDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'erf', 'erfinv'],
    "HalfStudentTDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'CauchyDistribution', 'HalfCauchyDistribution', 'HalfNormalDistribution', 'NormalDistribution', 'StudentTDistribution', 'log1p', 'regularizedIncompleteBeta', 'lngamma', 'norm', 'findRootTrustRegion', 'erf', 'erfinv', 'betacf', 'dot', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "InverseGammaDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'GammaDistribution', 'lngamma', 'gammaincU', 'gammaincL', 'norm', 'findRootTrustRegion', 'secantSolve', 'brentSolve', 'dot', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "InverseGaussianDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'logSumExp', 'lnStdNormCdf', 'findRootTrustRegion', 'newtonSolve', 'log1p', 'erfc', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "LogNormalDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'erf', 'erfinv'],
    "NormalDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'erf', 'erfinv'],
    "ParetoDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "StudentTDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'CauchyDistribution', 'NormalDistribution', 'log1p', 'erfinv', 'regularizedIncompleteBeta', 'lngamma', 'norm', 'findRootTrustRegion', 'erf', 'betacf', 'dot', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "UniformDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "VonMisesDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution', 'NormalDistribution', 'isclose', 'erf', 'besseli0', 'cosm1', 'clenshawCurtisIntegrate', 'findRootTrustRegion', 'brentSolve', 'erfinv', 'chbevl', 'polevl', 'chebPoints', 'clenshawCurtisWeights', 'dot', 'transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "WeibullDistribution": ['UnivariateDistribution', 'ContinuousUnivariateDistribution'],
    "isclose": [],
    "isone": ['isclose'],
    "iszero": [],
    "logspace": [],
    "linspace": [],
    "arange": [],
    "meshgrid": [],
    "logit": [],
    "log1p": [],
    "logSumExp": ['log1p'],
    "erf": [],
    "erfc": [],
    "erfinv": [],
    "lnStdNormCdf": ['log1p', 'erfc'],
    "lnchoice": ['lnfactorial'],
    "lnbeta": ['lngamma'],
    "betacf": [],
    "regularizedIncompleteBeta": ['log1p', 'betacf', 'lngamma'],
    "incompleteBeta": ['lnbeta', 'regularizedIncompleteBeta', 'lngamma', 'log1p', 'betacf'],
    "lngamma": [],
    "gammaincU": ['lngamma', 'gammaincL', 'gammaincU'],
    "gammaincL": ['lngamma', 'gammaincU', 'gammaincL'],
    "hyp1f1": ['lngamma'],
    "chbevl": [],
    "polevl": [],
    "besseli0": ['chbevl'],
    "cosm1": ['polevl'],
    "chebPoints": [],
    "clenshawCurtisWeights": [],
    "clenshawCurtisIntegrate": ['chebPoints', 'clenshawCurtisWeights', 'dot'],
    "lnfactorial": [],
    "transpose": [],
    "mvMult": ['dot'],
    "svMult": [],
    "smMult": ['svMult'],
    "svAdd": [],
    "mmMult": ['zeros', 'deepCopy'],
    "vectorAdd": [],
    "elementwiseVectorDivide": [],
    "elementwiseVectorMult": [],
    "svMultAdd": [],
    "absVector": [],
    "dot": [],
    "norm": ['dot'],
    "quadForm": ['mvMult', 'dot'],
    "shallowCopyMatrix": [],
    "deepCopy": [],
    "zeros": ['deepCopy'],
    "lowerTriSolve": [],
    "upperTriSolve": [],
    "modifiedCholesky": ['arange', 'deepCopy'],
    "modifiedCholeskySolve": ['transpose', 'lowerTriSolve', 'upperTriSolve'],
    "solvePosDef": ['zeros', 'modifiedCholesky', 'modifiedCholeskySolve', 'deepCopy', 'arange', 'transpose', 'lowerTriSolve', 'upperTriSolve'],
    "LUPDecompose": ['shallowCopyMatrix'],
    "LUPSolve": [],
    "solve": ['zeros', 'modifiedCholesky', 'modifiedCholeskySolve', 'solvePosDef', 'deepCopy', 'arange', 'transpose', 'lowerTriSolve', 'upperTriSolve'],
    "paramsFromSliders": [],
    "paramsFromBoxes": [],
    "setYRanges": [],
    "checkQuantileInput": [],
    "updateContinuousPDFandCDF": ['linspace', 'paramsFromSliders'],
    "updateDiscretePMFandCDF": ['arange', 'paramsFromSliders'],
    "updateData": ['updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'paramsFromSliders', 'arange'],
    "updateQuantiles": ['paramsFromSliders'],
    "quantileSetter": ['paramsFromSliders', 'paramsFromBoxes', 'setYRanges', 'checkQuantileInput', 'updateData', 'updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'arange'],
    "jacCentralDiff": ['deepCopy', 'zeros'],
    "findRootTrustRegion": ['transpose', 'mvMult', 'mmMult', 'vectorAdd', 'norm', 'deepCopy', 'computeRho', 'checkTol', 'doglegStep', 'jacCentralDiff', 'dot', 'zeros', 'svMult', 'quadForm', 'solvePosDef', 'modifiedCholesky', 'modifiedCholeskySolve', 'arange', 'lowerTriSolve', 'upperTriSolve'],
    "computeRho": ['mvMult', 'vectorAdd', 'norm', 'dot'],
    "checkTol": [],
    "doglegStep": ['svMult', 'vectorAdd', 'dot', 'norm', 'quadForm', 'solvePosDef', 'mvMult', 'zeros', 'modifiedCholesky', 'modifiedCholeskySolve', 'deepCopy', 'arange', 'transpose', 'lowerTriSolve', 'upperTriSolve'],
    "bisectionSolve": [],
    "newtonSolve": [],
    "secantSolve": [],
    "brentSolve": [],
    "slider_start_callback": [],
    "slider_end_callback": [],
    "int_slider_start_callback": [],
    "int_slider_end_callback": [],
    "quantile_setter_switch_callback": [],
    "quantile_setter_callback": ['quantileSetter', 'paramsFromSliders', 'paramsFromBoxes', 'setYRanges', 'checkQuantileInput', 'updateData', 'updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'arange'],
    "reset_button_callback": ['paramsFromSliders', 'setYRanges', 'updateData', 'updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'arange'],
    "slider_callback": ['updateData', 'updateQuantiles', 'quantileSetter', 'updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'paramsFromSliders', 'arange', 'paramsFromBoxes', 'setYRanges', 'checkQuantileInput'],
    "xaxis_change_callback": ['updateData', 'updateContinuousPDFandCDF', 'updateDiscretePMFandCDF', 'linspace', 'paramsFromSliders', 'arange'],
}